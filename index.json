[{"content":"\n\n不多说，大纲走一波\n\n- Dubbo 是什么？\n- 如何使用？\n- 注册中心\n- 多协议支持\n- 多版本支持\n- 启动检查\n- 集群容错\n- 降级\n\n## Dubbo 是什么？\n\n我要直接说《分布式服务治理框架》讲道理没了解过的小伙伴应该是直接一脸懵逼，那么就从其主要想解决什么问题开始吧，首先说说历史\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft8ao6bdjvj20nk0cawg5.jpg)\n从经典的单体架构说起，通常这样是没有什么问题的，直到现在都很常用，然而随着用户量的增加，扩展性能也很方便，加服务器可以了，但随着用户越来越多，增加服务器的成本也大大的提高了，而且很多地方也容易造成性能的浪费，随着越加越多，渐渐的带来的提升也不是那么的明显了，开发维护起来也非常臃肿，于是就想把它拆分，例如这里我将它水平拆分，将所有的系统都拆分成单个一体的服务，这样利于开发维护和做技术积累，在扩展性能的时候也可以有针对的扩展\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft8cotv6yvj21480eugp9.jpg)\n在我们水平拆分后，例如调用下订单这个服务，服务之间的交互是这样的，如上图，那么在这个通信的过程会遇见什么问题？\n\n1.  地址的维护，随着机器越来越多，各个服务部署在不同的机器上，他们地址也不一样\n2.  负载均衡\n3.  容错\n4.  降级\n5.  服务之间存在不同协议的通信\n6.  服务之间调用的监控\n7.  服务之间依赖关系，如那些服务依赖于那些服务，比如那些服务必须要等待依赖的服务先启动自己才能够启动\n8.  ….\n\n所谓的治理我个人理解起来就是：解决与管理\n\n在 Dubbo 的架构中有 4 中角色\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft8coffhwdj20so0ie774.jpg)\n该图借鉴至 Dubbo 官方文档\n\n**Provider**\n\n服务提供者，提供服务给予消费者消费\n\n**Registry**\n\n注册中心，提供者将服务注册至注册中心，消费者向注册中心订阅，一旦服务发生变动都会通知消费者，其实就是服务的发现与注册\n\n** Consumer **\n\n服务消费者，没什么好说的\n\n** Monitor **\n\n监视者，监控服务的调用次数与调用时间\n\n## 如何使用？\n\n首先我创建 2 个项目，一个分别叫做`dubbo-server-demo`一个叫做`dubbo-client-demo`，分别都使用`Maven`来构建\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft8d38fsgsj20gm0e63zk.jpg)\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft8d9nau3dj20h80agjsc.jpg)\n\n接着在`server-api`模块里创建一个对外提供服务的接口`TestService`\n\n```\npackage org.yuequan.dubbo.demo;\n\npublic interface TestService {\n    String sayHello(String msg);\n}\n```\n\n接着在`server-provider`中对该接口实现，当然也要添加对`server-api`的依赖\n\n```\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.yuequan.dubbo.demo\u003c/groupId\u003e\n    \u003cartifactId\u003eserver-api\u003c/artifactId\u003e\n    \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e\n\u003c/dependency\u003e\n\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.yuequan.dubbo.demo\u003c/groupId\u003e\n    \u003cartifactId\u003eserver-api\u003c/artifactId\u003e\n    \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e\n\u003c/dependency\u003e\n```\n\n随后对该接口进行实现\n\n```\npackage org.yuequan.dubbo.demo;\n\npublic class TestServiceImpl implements TestService {\n    @Override\n    public String sayHello(String msg) {\n        return \"Hi，Customer：\" + msg;\n    }\n}\n```\n\n首先引入依赖\n\n```\n\u003cdependency\u003e\n    \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e\n    \u003cartifactId\u003edubbo\u003c/artifactId\u003e\n    \u003cversion\u003e2.5.10\u003c/version\u003e\n\u003c/dependency\u003e\n```\n\n接着在`/META-INF/dubbo/dubbo-server.xml`中做一下配置，首先我们来配置一个简单的\n\n```\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://code.alibabatech.com/schema/dubbo      http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"\u003e\n    \u003cdubbo:application name=\"dubbo-server\" owner=\"yuequan\" /\u003e\n    \u003cdubbo:registry address=\"N/A\" /\u003e\n    \u003cdubbo:service interface=\"org.yuequan.dubbo.demo.TestService\" ref=\"testService\" /\u003e\n    \u003cbean class=\"org.yuequan.dubbo.demo.TestServiceImpl\" name=\"testService\" \u003e\u003c/bean\u003e\n\u003c/beans\u003e\n```\n\n接着我们来写一个`main`函数用于启动它，有 2 种方式一种是使用`Spring`容器启动方式，还有一种是使用 Dubbo 的`Main.main`启动，这里我暂时先用`Spring`容器启动\n\n```\npublic class App\n{\n    public static void main(String[] args) throws IOException {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"META-INF/dubbo/dubbo-server.xml\");\n        context.start();\n        System.in.read();\n    }\n}\n```\n\n接着启动应用，可以看到日志的输出\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft95eecog4j21ty0ekdmh.jpg)\n同时也看到服务发布成功了\n\n接着来`dubbo-client-demo`，首先引入`dubbo`依赖\n\n```\n\u003cdependency\u003e\n  \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e\n  \u003cartifactId\u003edubbo\u003c/artifactId\u003e\n  \u003cversion\u003e2.5.10\u003c/version\u003e\n\u003c/dependency\u003e\n```\n\n接着写配置文件`META-INF/dubbo/dubbo-client.xml`\n\n```\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://code.alibabatech.com/schema/dubbo      http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"\u003e\n    \u003cdubbo:application name=\"dubbo-client\" owner=\"yuequan\" /\u003e\n    \u003cdubbo:registry address=\"N/A\" /\u003e\n\t  \u003cdubbo:reference interface=\"org.yuequan.dubbo.demo.TestService\" url=\"dubbo://192.168.10.102:20880/org.yuequan.dubbo.demo.TestService\" /\u003e\n\u003c/beans\u003e\n```\n\n还记得控制台日志输出的地址吗，这里就是了，现在暂时不用注册中心，先来一个最简单的点对点通信，接着我们来写客户端的启动类，通信协议默认是使用的`dubbo`其默认端口就是 20880\n\n```\npublic class App\n{\n    public static void main( String[] args )\n    {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"META-INF/dubbo/dubbo-client.xml\");\n        TestService service = (TestService) context.getBean(\"testService\");\n        System.out.println(service.sayHello(\"YueQuan\"));\n    }\n}\n```\n\n接着启动它\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft95ppynwrj21u80a2n0f.jpg)\n至此，一个简单的使用例子就写好了，接着进入下一个小节\n\n## 注册中心\n\n上一个小节的例子，我们使用点对点通信的例子，接着我们来配置注册中心，`dubbo`默认支持能够用来做注册中心的有\n\n- Multicast\n- Zookeeper\n- Redis\n- Simple\n  这里官方推荐使用 Zookeeper，不会 Zookeeper 可以看我之前写的文章，首先来修改`dubbo-server.xml`注册中心配置\n\n```\n\u003c!-- N/A 代表着没有，不使用的意思 --\u003e\n\u003cdubbo:registry address=\"N/A\" /\u003e\n\u003c!-- 修改成，当然你要启动ZooKeeper --\u003e\n\u003cdubbo:registry address=\"zookeeper://127.0.0.1:2181\" /\u003e\n```\n\n接着引入 ZooKeeper 依赖\n\n```\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.apache.zookeeper\u003c/groupId\u003e\n    \u003cartifactId\u003ezookeeper\u003c/artifactId\u003e\n    \u003cversion\u003e3.4.12\u003c/version\u003e\n    \u003ctype\u003epom\u003c/type\u003e\n\u003c/dependency\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003ecom.101tec\u003c/groupId\u003e\n    \u003cartifactId\u003ezkclient\u003c/artifactId\u003e\n    \u003cversion\u003e0.10\u003c/version\u003e\n\u003c/dependency\u003e\n```\n\n接着启动\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft962ircsgj21ys0hitcj.jpg)\n发现日志什么都没有输出，接着配置下日志`log4j.properties`\n\n```\nlog4j.rootLogger=INFO, stdout\n\n# Direct log messages to stdout\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target=System.out\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n\n```\n\n接着重启，可以看到控制台有日志输出了\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft967oulyhj21ve0fmdmy.jpg)\n\n接着看看来看看 Zookeeper 这边\n\n```\n// 运行客户端\n./zkCli.sh\n```\n\n输入`ls /`\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft96a9c1juj20js02m74n.jpg)\n\n可以看到下面多了一个 dubbo 节点，接着来看下 dubbo 节点下的内容：`ls /dubbo`\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft96h5iy2tj20j4026gly.jpg)\n\n可以看到接口已经被注册上来了，接着我们看看这个接口下的内容：\n\n```\nls /dubbo/org.yuequan.dubbo.demo.TestService\n```\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft96j72liyj20ve026t95.jpg)\n可以看到下面现在就 2 个节点,我们来看看现在有多少个 providers:\n\n```\nls /dubbo/org.yuequan.dubbo.demo.TestService/providers\n```\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft96jbgz18j20vm050myq.jpg)\n可以看到已经注册上来了\n\n接着来配置下`dubbo-client-demo`，首先引入依赖\n\n```\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.apache.zookeeper\u003c/groupId\u003e\n    \u003cartifactId\u003ezookeeper\u003c/artifactId\u003e\n    \u003cversion\u003e3.4.12\u003c/version\u003e\n    \u003ctype\u003epom\u003c/type\u003e\n\u003c/dependency\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003ecom.101tec\u003c/groupId\u003e\n    \u003cartifactId\u003ezkclient\u003c/artifactId\u003e\n    \u003cversion\u003e0.10\u003c/version\u003e\n\u003c/dependency\u003e\n```\n\n然后修改配置`dubbo-client.xml`\n\n```\n\u003c!-- 修改前 --\u003e\n\u003cdubbo:registry address=\"N/A\" /\u003e\n\u003c!-- 修改后 --\u003e\n\u003cdubbo:registry address=\"zookeeper://127.0.0.1:2181\" /\u003e\n\n\u003c!-- 修改前 --\u003e\n\u003cdubbo:reference id=\"testService\" interface=\"org.yuequan.dubbo.demo.TestService\" url=\"dubbo://192.168.10.102:20880/org.yuequan.dubbo.demo.TestService\" /\u003e\n\u003c!-- 修改后 --\u003e\n\u003cdubbo:reference id=\"testService\" interface=\"org.yuequan.dubbo.demo.TestService\" /\u003e\n```\n\n接着启动，可以看到日志输出\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft96q0t62zj21sy09iac7.jpg)\n接着我们再来看下 Zookeeper：\n\n```\nls /dubbo/org.yuequan.dubbo.demo.TestService\n```\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft973qukjrj20vc02sq3l.jpg)\n可以看见多了 2 个节点分别为`routers`和`consumers`这时候输入\n```\nls /dubbo/org.yuequan.dubbo.demo.TestService/comsumers\n```\n会发现返回的是一个空数组，这是因为客户端的消费已经结束了，所以该下的节点也会被清除，这一特性可以很好的利用 Zookeeper 的临时节点来实现，实际上它也是这样做的，接着我们来修改下客户端的代码让他不那么快结束\n\n```\npublic class App\n{\n    public static void main( String[] args ) throws InterruptedException {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"META-INF/dubbo/dubbo-client.xml\");\n        TestService service = (TestService) context.getBean(\"testService\");\n        System.out.println(service.sayHello(\"YueQuan\"));\n        Thread.sleep(10000);\n    }\n}\n```\n\n启动后，再来看看\n\n```\nls /dubbo/org.yuequan.dubbo.demo.TestService/comsumers\n```\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft973w42suj20vk06m40g.jpg)\n\n可以看到消费者信息，这是单个配置注册中心，那如果有多个呢？配置多注册中心也非常简单，如下：\n\n```\n\u003cdubbo:registry protocol=\"zookeeper\" address=\"192.168.1.1:2181,192.16.1.2:2181,192.168.1.3:2181\" /\u003e\n\u003c!-- OR --\u003e\n\u003cdubbo:registry address=\"zookeeper://192.168.1.1:2181?backup=192.16.1.2:2181,192.168.1.3:2181\" /\u003e\n\u003c!-- 更多可以看官方文档~~~ --\u003e\n```\n\n## 多协议\n\n我们一个服务可能之前是使用的`dubbo`协议但后面又改成了`hessian`协议，也有可能一个服务提供了`dubbo`协议也提供了`hessian`协议，但也有的客户端它只使用一种协议的通信方式，在多协议的情况下，`Dubbo`框架也做了很好的实现接着修改`dubbo-server.xml`文件，这里我将会使用`hessian`和`dubbo`2 个协议,所以需要先引入`hessian`的依赖，这里需要使用到容器所以还需要引入`servlet-api`和一个`servlet`容器，那这里我就使用`jetty`，添加的依赖如下\n\n```\n\u003cdependency\u003e\n    \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e\n    \u003cartifactId\u003ejavax.servlet-api\u003c/artifactId\u003e\n    \u003cversion\u003e4.0.1\u003c/version\u003e\n    \u003cscope\u003eprovided\u003c/scope\u003e\n\u003c/dependency\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.mortbay.jetty\u003c/groupId\u003e\n    \u003cartifactId\u003ejetty\u003c/artifactId\u003e\n    \u003cversion\u003e6.1.26\u003c/version\u003e\n\u003c/dependency\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003ecom.caucho\u003c/groupId\u003e\n    \u003cartifactId\u003ehessian\u003c/artifactId\u003e\n    \u003cversion\u003e4.0.51\u003c/version\u003e\n\u003c/dependency\u003e\n```\n\n接着修改配置\n\n```\n\t\u003cdubbo:protocol name=\"dubbo\" port=\"20880\" /\u003e\n\t\u003cdubbo:protocol name=\"hessian\" port=\"8011\" /\u003e\n\t\u003cdubbo:service interface=\"org.yuequan.dubbo.demo.TestService\" ref=\"testService\" protocol=\"dubbo,hessian\" /\u003e\n```\n\n接着启动，这样就配置好了，但是这样看不到明显的效果啊？我怎么知道我客户端再未指定协议的情况下消费的是`hessian`协议还是`dubbo`协议？于是为了演示可以这样做将`TestServiceImpl`在复制一份，修改下其中内容\n\n```\npublic class TestService2Impl implements TestService {\n    @Override\n    public String sayHello(String msg) {\n        return \"Hi,Customer：\" + msg + \"，through Hessian protocol\";\n    }\n}\n```\n\n然后再调整下配置\n\n```\n\u003cbean class=\"org.yuequan.dubbo.demo.TestServiceImpl\" name=\"testService\" \u003e\u003c/bean\u003e\n\u003cbean class=\"org.yuequan.dubbo.demo.TestService2Impl\" name=\"testService2\"\u003e\u003c/bean\u003e\n\u003cdubbo:service interface=\"org.yuequan.dubbo.demo.TestService\" ref=\"testService\" protocol=\"dubbo\" /\u003e\n\u003cdubbo:service interface=\"org.yuequan.dubbo.demo.TestService\" ref=\"testService2\" protocol=\"hessian\" /\u003e\n```\n\n接着启动，然后为了明显，再修改下客户端的调用代码并引入依赖，让它调用十次，可以看出这十次分别调用的那个\n\n```\n\u003cdependency\u003e\n  \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e\n  \u003cartifactId\u003ejavax.servlet-api\u003c/artifactId\u003e\n  \u003cversion\u003e4.0.1\u003c/version\u003e\n  \u003cscope\u003eprovided\u003c/scope\u003e\n\u003c/dependency\u003e\n\u003cdependency\u003e\n  \u003cgroupId\u003eorg.mortbay.jetty\u003c/groupId\u003e\n  \u003cartifactId\u003ejetty\u003c/artifactId\u003e\n  \u003cversion\u003e6.1.26\u003c/version\u003e\n\u003c/dependency\u003e\n\u003cdependency\u003e\n  \u003cgroupId\u003ecom.caucho\u003c/groupId\u003e\n  \u003cartifactId\u003ehessian\u003c/artifactId\u003e\n  \u003cversion\u003e4.0.51\u003c/version\u003e\n\u003c/dependency\u003e\n```\n\n客户端代码修改如下\n\n```\npublic class App\n{\n    public static void main( String[] args ) throws InterruptedException {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"META-INF/dubbo/dubbo-client.xml\");\n        TestService service = (TestService) context.getBean(\"testService\");\n        for (int i = 0; i \u003c 10; i++) {\n            System./out/.println(service.sayHello(\"YueQuan\"));\n        }\n\n    }\n}\n```\n\n接着启动查看控制台输出\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft98o7pq1kj21u60ngaey.jpg)\nDubbo 默认的负载均衡机制是随机的，具体的会在后续文章细写\n\n## 多版本支持\n\n服务提供对外的接口可能会采取某种策略逐步平滑升级，例如原先使用 1.0.0 的接口，又对外提供了 2.0.0 处于刚刚开放，存在某些不稳定因素，可能想逐步开发，某些客户端继续使用 1.0.0，让一部分客户端先使用 2.0.0\n\n接着我们修改`dubbo-server.xml`\n\n```\n\u003c!-- 修改前 --\u003e\n\u003cdubbo:service interface=\"org.yuequan.dubbo.demo.TestService\" ref=\"testService\" protocol=\"dubbo\" /\u003e\n\u003cdubbo:service interface=\"org.yuequan.dubbo.demo.TestService\" ref=\"testService2\" protocol=\"hessian\"/\u003e\n\u003c!-- 修改后 --\u003e\n\u003cdubbo:service interface=\"org.yuequan.dubbo.demo.TestService\" ref=\"testService\" protocol=\"dubbo\" version=\"1.0.0\" /\u003e\n\u003cdubbo:service interface=\"org.yuequan.dubbo.demo.TestService\" ref=\"testService2\" protocol=\"hessian\" version=\"2.0.0\" /\u003e\n```\n\n对于 1.0.0 的接口访问使用`dubbo`协议，2.0.0 的接口访问使用`hessian`\n然后修改客户端配置`dubbo-client.xml`\n\n```\n\u003cdubbo:reference id=\"testService\" interface=\"org.yuequan.dubbo.demo.TestService\" version=\"1.0.0\" /\u003e\n```\n\n然后运行，你会发现只会调用定义的`1.0.0`版本的服务，`2.0.0`同理\n\n## 启动检查\n\n在服务的启动过程中可能有依赖于其它服务，但其它服务并没有运行起来，这时候你先起起来了，必然会报错，更有意思的是如果是互相依赖，那互相都起不来怎么办呢？所以这里就要关闭启动检查，例如\n\n```\n\u003c!-- 修改前 --\u003e\n\u003cdubbo:reference id=\"testService\" interface=\"org.yuequan.dubbo.demo.TestService\" version=\"1.0.0\" /\u003e\n\u003c!-- 修改后 --\u003e\n\u003cdubbo:reference id=\"testService\" interface=\"org.yuequan.dubbo.demo.TestService\" version=\"1.0.0\" check=\"false\"/\u003e\n```\n\n## 集群容错\n\n在集群调用中出现调用失败时，比如所需要调用的服务它一直未返回数据阻塞住了，直到超时等情况，对于调用失败 Dubbo 提供了几种容错方案，分别是\n\n1.  Failover\n2.  Failfast\n3.  Failsafe\n4.  Failback\n5.  Forking\n6.  Broadcast\n\n** Failover **\n\n默认就是它，失败后自动切换，当出现失败后，自动切换其它服务器，当然可以设置重试次数\n\n** Failfast **\n\n快速失败，失败后就立马报错\n\n** Failfast **\n\n安全失败，发生异常，立马吞掉，也就是直接忽略\n\n** Failback **\n\n失败后自动恢复\n\n** Forking **\n\n同时并行调用几个相同的服务，只要一个成功即返回，但可以设置最大并行数\n\n** Broadcast **\n\n广播调用所有提供者，挨个调用，只要有一个报错就报错\n\n通常可以通过配置可以对容错的手段进行更改，如下：\n\n```\n\u003c!-- 修改前 --\u003e\n\u003cdubbo:reference id=\"testService\" interface=\"org.yuequan.dubbo.demo.TestService\" check=\"false\" version=\"1.0.0\" /\u003e\n\u003c!-- 修改后 --\u003e\n\u003cdubbo:reference cluster=\"failsafe\" id=\"testService\" interface=\"org.yuequan.dubbo.demo.TestService\" check=\"false\" version=\"1.0.0\" /\u003e\n```\n\n这里我配置的`failsafe`所以消费者调用该服务的提供者就算出现异常也会被忽略掉，为了演示效果，我这里将超时时间修改为 50 毫秒\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft9uy1pd8ij21i40is0xf.jpg)\n因为我这里是本机所以 50 毫秒也还是有执行成功的现象不过无所谓，看第一个`null`执行失败的异常并没有输出而是直接返回了 null\n\n## 降级\n\n降级我用一个比较笼统的说法来简单的阐述一下，降级实际上就是关闭或者减少其它服务所占用的资源来保证核心服务可用，就比如小米的饥饿营销或者在双 11 下单的时候经常会出现服务器繁忙，请稍后再试，再比如说在双 11 下单高峰的时候，为了集中资源，将平时首页给推荐的数据分析并推送给我的相关服务全部关掉，仅保留基本核心服务，等高峰期一过在把这些附加服务开放，实际上降级有很多种，比如：页面降级、读降级、写降级、超时降级、开关降级等等等，反正这里 get 到点就可以了，以后应该是有机会来单独说降级这个概念的。\n对于服务降级 Dubbo 也是提供了相应的机制来让我们处理的。\n就比如说一个接口超过了 50 毫秒的响应时间我们就对它进行降级，来保证它基本可用，来写个 demo 修改配置文件`dubbo-client.xml`\n\n```\n\u003c!-- 修改前 --\u003e\n\u003cdubbo:reference cluster=\"failsafe\" id=\"testService\" interface=\"org.yuequan.dubbo.demo.TestService\" check=\"false\" version=\"1.0.0\" /\u003e\n\u003c!-- 修改后 --\u003e\n\u003cdubbo:reference id=\"testService\" interface=\"org.yuequan.dubbo.demo.TestService\" check=\"false\" version=\"1.0.0\" mock=\"org.yuequan.dubbo.demo.TimeoutMock\" timeout=\"50\"/\u003e\n```\n\n这里值得一提的是，可以发现我将`cluster`因为这里如果是使用的`failsafe`的话是不会降级的，而是直接走`failsafe`的机制的，接着运行，我们来看下控制台\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft9vce24rrj219u0g6dk1.jpg)\n可以看到调用超过了 50 毫秒的会直接降级，本节就先到这里。\n\n\n如果你觉得作者写的这篇文章对你有帮助或者收获很大的话，你可以尝试着请我喝一瓶《东方树叶》或者吃一块《\u001d鸡胸》来激励我！！！\n\n**微信请客**\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmntt0mzpj20yi1auaki.jpg)\n\n\n**支付宝请客**\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnun44gdj20go0p00y2.jpg)","cover":"","link":"dubbo_base.html","preview":"\u003cp\u003eDubbo(一)入门\u003c/p\u003e\n","title":"Dubbo(一)入门"},{"content":"\n\n嗯，我想想从什么地方写起比较好呢，我觉得从分布式的Leader选举，还有它消息同步的分布式事务说起吧，大纲走一波\n\n* 为什么需要选举Leader\n* 如何选举Leader的及使用什么机制达到数据一致性\n* 简单阅读下Leader选举的源码\n\n## 为什么需要选举Leader\n要了解这个问题，首先要很明确的知道ZooKeeper集群下几个角色的主要分工(Leader、Follower、Observer)\n\n**Leader**\n\n* 处理跟事务相关的操作(增、删、改)\n* 将消息同步到旗下的Follower\n* 集群内部各服务器的调度者同时保证事务处理的顺序性\n\n**Follower**\n\n* 将跟事务处理相关的操作转发到其对应的Leader\n* 参与事务请求Propsal投票(因为在同步消息时，只有大多*数Follower都事务提交成功，该次提交才算成功，否则进行回滚)\n* 参与Leader的选举\n\n**Observer**\n\n仅作为观察者，观察ZooKeeper中集群的最新状态并且把集群的最新状态更新到Observer中，它不参与Propsal投票也不参与选举，只是在一旁静静的在不影响事务性能的情况下提升非事务处理的能力。\n\n在明白了这些问题了后，来聊聊为什么需要选择Leader？在搞清楚这个问题之前我们再回归到本源，我们为什么需要集群？假如我们使用了ZooKeeper把它用作我们的注册中心\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43mo2zblj20m60i2mzn.jpg)\n\n在有很多个服务都注册在ZooKeeper上，那我们要如何保障其高可用呢？最简单和有效的办法那便是做集群，一旦我们做了集群，那么首先解决的问题就是单点故障的问题，不会因为一台机器的宕机从而导致所有依赖ZooKeeper的服务都不能使用，从而再从集群的这个实现中分摊了来自各服务的流量，从而提升了性能。\n\n那从上面的点出发，看我们要一个高性能高可用的集群，那么ZooKeeper是如何做到的，很简单它直接化繁至简，在ZooKeeper这种分布式协调服务其自身又需要存储数据，那么首先就要保障集群中的数据一致性，那么要是每个节点都能写入数据，那么为了达到数据一致性，那么是不是都要通知各个服务器去同步这个节点更新了的数据，单单是这一步就已经很麻烦了，还要对更新不成功的节点进行重新更新等，整个事情的复杂度就变得很高了，所以这里直接定义一个Leader节点，将所有的事务节点都转发到Leader节点上来处理，通过Leader节点来下发事务给各个Follower节点进行同步，所有的非事务请求任何节点接收到都可以自行处理掉，整个事情就变得简单起来了，但Leader节点一旦宕机挂掉后，这些Follower节点也会立马选举一个Leader节点出来继续干Leader节点的事情，那么是如何选举Leader的呢？如果有十个事务，Leader节点处理到一半还剩五个事务未处理，新选举出来的Leader又是如何处理的呢？旧的Leader上线后对自身未完成的事务又该何去何从呢？跟着我的思路，看下一个小节\n\n## 如何选举Leader的及使用什么机制达到数据一致性\n\n了解这个问题之前先了解一件事情，通常ZooKeeper都是由2n + 1台Server组成，对于2n+1台Server只要有n+1台Server可用，那么整个系统就保持可用，怎么理解这个概念呢？就是过半的意思理解吧？如果有3台机器组成的集群其挂掉1台还剩2台任然可以正常工作，如果有5台机器的集群能够在对2台机器挂掉的情况下还能正常工作并且做出相应的容灾处理，反正过半就对了，之所以要满足一个这样的集群是因为其集群中会有一个节点会成为该集群中的Leader需要有超过该集群过半数的节点支持，有了这个概念，我们继续深入的来理解下是如何选举Leader的。\n\n这里可以很简单的描述，但你不一定能看懂，但没关系跟着我的节奏你肯定能看懂，ZooKeeper的选举通常情况由\n\n* zxid\n* myid\n\n来决定谁是Leader，那么这里又会疑问什么是zxid什么是myid?\n\n**zxid**\n\nzxid是一个64位的有规则编号，其高的32位是epoch编号，其低的32位是消息计数器，没接收到一条消息，该消息计数器就会累加加1，但这里奇怪的是什么是epoch编号，epoch编号理解起来并不难，它实际上就是每一轮投票选举Leader都会+1的一个计数器，可在每台节点机器的`/tmp/zookeeper/acceptedEpoch`文件来查看当前epoch是几，一个epoch就是一个王的上任\n\n**myid**\n\n看过上一篇的myid是什么还要解释吗？没看过的赶快去看\n\n接下来说一下其选举机制，首先每个节点启动的状态都是LOOKING状态，处于观望状态，然后其内部开始执行选举，每个Server都会向节点之间互相广播投票，每次投票信息都会包含所推举的服务器的myid和zxid，实际上刚启动大家推的都是自己，我们这里使用 (myid, zxid)来表示，Server1投出去的信息(1, 0)、Server2投出去的信息(2, 0),首先会根据ZXID来选举谁是Leader节点可以看到2者的zxid都为0那么接着比较其myid，Server2的myid要比server1的大那么应该是投给server2来做Leader节点，那么经过这一步后开始统计投票集群中的投票信息，只要根据该步骤选举投票大于过半的机器时此时便认为已经选举出Leader，即刻改变集群节点之间的状态是Follower都就更新自己的节点为Following，是Leader就更新自己的状态为Leading\n\n上面简单的说了下选举机制但有没有考虑过，如果在使用过程中Leader突然挂掉了？Leader是如何重新进行选举的？\n\n说这个问题之前我们要来了解下ZAB协议，ZAB(ZooKeeper Atomic Broadcast)是一种专门为ZooKeeper设计的原子广播协议，用其保证在分布式数据中的数据一致性，该协议有2种最基本的模式分别为：崩溃恢复、原子广播。\n\n当集群刚启动或者Leader节点宕机时整个集群就会进入一个恢复模式来选举一个Leader，当有过半的机器与该Leader节点连接并且完成数据同步时基于ZAB协议就会退出恢复模式，当有过半的Follower节点完成了和Leader节点的数据同步后，整个集群就进入了消息广播模式，如果在一个完整的集群中再添加了一个新的节点，那么这个节点就会进入紧急模式，通过完成与Leader的同步后，再度转为消息广播模式。\n\n**原子广播**\n\nZooKeeper的原子广播实际上是基于一个简化版的2PC提交过程，熟悉分布式事务的应该了解2PC，我这里就不详细介绍什么是2PC了，等哪天我可能会心血来潮写一篇分布式事务相关的文章时，再好好介绍什么是2PC什么是3PC吧~\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43o4onujj21640h4wka.jpg)\n\n根据我画的图，我在文字详述一遍\n1.Leader接收到事务时首先会对该事务生成一个zxid(都还记得这个是啥吧？)\n2.在Leader中有一个FIFO队列专门用来存放proposal，这个proposal实际上就是将带有zxid的消息封装成一个proposal，在使用FIFO队列进行有序分发。\n3.在Follower接收到请求后，会对该proposal写入磁盘，然后会服务器返回一个结果ACK\n4.服务器收到过半的成功ACK时，就会对Follower发送commit指令，同时本地也会执行\n5.当Follower收到commit指令后，执行commit\n\n**崩溃恢复**\n\n一旦有Leader节点宕机或者Leader节点失去了大半Follower节点的连接，可能因为网络波动，那么此时的Leader就不再是一个合法的Leader，那么就会进入崩溃恢复模式，在ZAB协议中为了保障正确性，整个恢复过程结束后需要选举一个新的Leader，为了使得崩溃后还能选举出新的Leader来进行正常工作首先要保证2件事\n\n* 已经被处理的事务不能丢失\n* 过时的事务不能再出现\n\n*已经被处理的事务不能丢失*\n怎么理解呢？很简单，根据原子广播Leader收到ACK后会对Follower节点发出commit指令，当这个指令指向了一台机器发送还未向其它机器发送，自己就挂了，那么这个事务已经发送给了一个节点commit就代表已经被处理过了\n\n*过时的事务不能再出现*\n就比如我Leader节点目前接收了10个事务，生成了10个proposal，当还没有发送就已经挂了，也就是没有一个follower接收到了该事务，此时会进入崩溃恢复模式，选举出新的Leader，当这台老Leader恢复了，连接上了它也只能做一个Follower节点，其自身没有处理过的事务也应该视为过时应该进行丢弃\n\n\n那么这里就很灵性了？想想选举机制崩溃后如何选举新的Leader？如果有节点执行了commit那么它的zxid是不是比较大，那么这些执行了commit的节点就是极有可能是leader节点，如果只有一台执行了commit，不出其它牛角尖的话，那么它就是Leader，因为它是最新的嘛！\n\n## 简单看下ZooKeeper选举源码\n首先我们从一个具有main函数的`QuorumPeerMain`类开始，我们就以它为入口吧\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43oqozi2j20ys0lk0y6.jpg)\n\n会发现他创建了一个`QuorumPeerMain`的实例并执行了其`initializeAndRun`方法\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43p8jutjj210g0lqjvs.jpg)\n\n如果是集群就会执行`runFromConfig`这个方法里做了一堆配置，简单看下不用太过关心，重点不是这，接着继续看，可以看到它调用了一个`start`方法\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43pk72t8j20j40703zd.jpg)\n\n`loadDataBase`就恢复其自身数据库其实就是从本地文件中恢复数据，然后获取最新的zxid，关键是这里的`startLeaderElection`看到这个方法名，就知道了吧？在这里开始选举惹~\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43pswdafj210w0r0gr0.jpg)\n\n这里会获取自身的`myid`和`zxid`还有`epoch`封装成`Vote`实例，顾名思义吧？先将自己的投票设置成自己的再说，关键最后一步，创建选举算法，跟着来看看\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43q22vs3j211a0sujw9.jpg)\n\n默认从config中读取出的是3，可以在`runFromConfig`中看到相关配置，首先创建了一个`QuorumCnxManager`的实例，该类主要负责Leader选举的IO，然后启动已绑定端口的选举监听现场，等待其他机器进行连接，然后创建一个`FastLeaderElection`实例\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43qbm6v3j20yw054t9k.jpg)\n\n关键看`starter`方法\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43qk33yaj20xu08a0ul.jpg)\n\n里面创建了2个队列，分别是一个接收队列和一个发送队列，然后创建了一个`Messenger`实例\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43qsjbq0j210c0g2ju4.jpg)\n\n该构造函数中设置了发送队列和接收队列的线程，并启动线程，WorkSender是负责发送投票的，WorkerReceiver是负责接收投票的，再回到`start`来\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43r0yu2xj20hs06qmxy.jpg)\n\n还发现其调用了父类的`start`方法，那么就直接看它的`run`方法不就好了嘛，这不就是覆盖了下`Thread`的`start`嘛？\n直接看`run`方法的关键点，看哪里还要我解释吗？当然是`LOOKING`状态了，这是一个观望状态\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43rki721j20ph1c1qjn.jpg)\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43rscapcj20xe068wfa.jpg)\n\n重点是这里通过makeLESStrategy()来选用一个选举算法进行Leader选举，接着看lookForLeader\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43s20sfej213c0be0wl.jpg)\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43s6u6zvj20yi0ng43i.jpg)\n\n这2个一个是用来存放收到的投票一个是存储选举结果的\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43sfj63zj20ya04oq3k.jpg)\n\n逻辑锁+1，并且更新自己的zxid和epoch\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43so9ecij20zy02igly.jpg)\n\n一直循环到选出Leader\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43svou0aj20ny04kdg8.jpg)\n\n从接收队列中拿投票信息\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43t5u82fj20sc0ectaw.jpg)\n\n如果队列拿出来的为空，那就是发完了，继续发送一直到选出leader\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43tdoy9qj20ts02i0t0.jpg)\n\n收到投票确认是否是本集群中的node投票\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43tm6vprj20vi0dkjud.jpg)\n\n如果收到的节点epoch大于logicallock则表示当前是一轮新的选举\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43u9482ej20v407mabj.jpg)\n\n拿自己的票和收到的票PK一波\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43uvg35bj211i040t97.jpg)\n\n先判断epoch是不是比当前的大，如果是比当前的大，那么我这个就是旧的，因为每一轮选举后都会epoch+1那么则是对方的大，那么对方胜出，对方是leader，如果epoch相等那么就判断zxid，如果对方的zxid大，那么对方胜出对方是leader，如果 epoch和zxid都相等，那么就判断myid，谁大谁胜出谁是它认可的Leader\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43v6owcyj20g20260sr.jpg)\n\n然后发送广播消息\n\n过完那一堆if后，添加本次收到的投票的对象，用来选举时的最终判断\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43vlcakxj210e02maac.jpg)\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43vq4wtdj20ve0deq5a.jpg)\n\n这里判断选举是否结束，默认算法就是超过半数server投票通过，这里的`while`结束以后\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft43w1j59vj20s40eqdi1.jpg)\n\n确定Leader和修改自身状态，即选举完毕\n\n就介绍到这里~~~ 我想想我下一篇是写《ZooKeeper Java API 及 Wacher原理》还是写Dubbo。\n\n如果你觉得作者写的这篇文章对你有帮助或者收获很大的话，你可以尝试着请我喝一瓶《东方树叶》或者吃一块《\u001d鸡胸》来激励我！！！\n\n**微信请客**\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmntt0mzpj20yi1auaki.jpg)\n\n\n**支付宝请客**\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnun44gdj20go0p00y2.jpg)","cover":"","link":"zookeeper_election_leader.html","preview":"\u003cp\u003eZooKeeper的一些原理了解一下？\u003c/p\u003e\n","title":"ZooKeeper的一些原理了解一下？"},{"content":"\n\n不多哔哔大纲先行\n\n* ZooKeeper是啥\n* ZooKeeper如何使用\n* ZooKeeper分布式搭建\n* ZooKeeper的应用场景\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13jhh8wij20fu08241j.jpg)\n\n\n## ZooKeeper是啥\n\nZooKeeper是一种分布式协调框架，最早是由雅虎的一个研究小组所开发，最早是用来解决分布式单点问题，因为技术氛围很多项目都是用动物命名，正好ZooKeeper是用于协调分布式应用因此得名“动物园管理员”(译过来是这样啊~)，那么什么是分布式单点问题，那么就要举一个简单的架构演技进例子来说明了（怕有钻牛角尖的，所以这里的架构演进是为了写这篇文章，笔者自己根据目前的知识想出来的演进，所以我的地盘听我的，不接受任何牛角尖）。\n\n首先从最原始的最常见的单体应用。\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13k53zbuj20su0j8dik.jpg)\n这个无需解释吧\n\n随着并发需求越来越大，一个顶不住了，然后按照这个架构再扩展一下\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13kfqufoj212i0l8gq0.jpg)\n\n每次拓展又他喵的要多开一个服务器然后在部署一套商城，而且很多系统都能用到类似的服务，难以达到复用的效果，而且扩展起来比较耗费财力，不能针对某一个点来进行性能的扩展，容易造成某些方面的浪费，例如 订单是一个高并发使用，而钱包是一个低并发，那么讲道理我只想针对并发高的这个服务进行性能的扩展，于是我们先将它拆成服务\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13kvb4ayj20h80jkq56.jpg)\n\n服务拆分好了以后我们再来扩展一哈\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13l6jplqj20k20kwn0c.jpg)\n\nOK，演进就先到这里，舞台搭建好了，我们来发现这其中的问题\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13lfuessj205i05cjs5.jpg)\n\n首先无论是水平扩展还是垂直扩展，有些许问题(以水平扩展来说，垂直差不多意会到了就行)这里挑几个针对的来说\n\n* 共享资源\n* 服务注册\n* 负载均衡\n\n其实这里就已经把应用场景说了，但这里只描述下问题，在应用场景的那一个小节再继续刻画，总的来说就是在分布式环境中的协调问题，例如共享资源，我几十几百个订单服务要同时使用一个共享资源，例如配置文件中的一些开关，通过修改配置文件的一些开关配置就能让我几百几千个服务同时打开，通过服务的注册来实现服务的统一地址管理、服务的上下线等，说到这里应该要对ZooKeeper分布式协调有点感觉了（如果还不能理解可以加微信共同探讨一下吧），那我就走进ZooKeeper了\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13lunl9mj207b06vmye.jpg)\n\n先介绍一下ZooKeeper的存储结构，它是以树形结构来存储但每个Node又都是一个Key-Value，说起来太抽象，画个图\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13m23xvcj216m0pwjy0.jpg)\n\n虚线连接的都是当前节点的value，实线连接之处便是其子节点了，这些子节点也有一个名字那便是ZNode,这下对ZooKeeper是个什么以及存储结构都有一个基本的了解了，接着进入下一个小节\n\n\n## ZooKeeper如何使用？\n首先说一下我的环境\n* CentOS7\n* OpenJDK8\n\n这便是我依赖的环境了\n自行去[Apache ZooKeeper](https://zookeeper.apache.org/)下载，然后解压，进入目录\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13mlkktgj20uk0580u7.jpg)\n\n首先进入`conf`目录\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13mvs1cbj20l0022mxg.jpg)\n\nZooKeeper默认会读取`zoo.cfg`文件，默认是没有的，但是有一个自带的`zoo_sample.cfg`文件，可以使用这个\n`cp zoo_sample.cfg zoo.cfg`，这里面写了什么我们暂时不关心，等会细讲，然后回退目录接着进入`bin`目录下\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13neelq9j20rw02qq3g.jpg)\n\n可以看到目录下有如下几个文件,首先启动ZooKeeper\n\n```\n./zkServer.sh start\n```\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13nzeu6nj20nu03e0tf.jpg)\n\n接着使用提供的客户端，连接它\n```\n./zkCli.sh\n```\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13oe93z0j20va0kw444.jpg)\n\n我们先来看看，默认有哪些数据\n\n```\nls /\n```\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13oqpai4j20ik01ydg0.jpg)\n可以看到默认只有一个zookeeper节点，接着我们来创建一个节点\n```\ncreate /a a \nls /\n```\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13p9cokwj20mk03q0t8.jpg)\n\n接着就可以看到我们所创建的节点，接着在继续给它创建一个子节点\n\n```\ncreate /a/aa aa\nls /a\n```\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13pki1k5j20ke0663zh.jpg)\n\n接着我们来创建一个临时节点，什么是临时节点呢，为什么叫临时有什么特殊之处呢？只需要记住2点，临时节点只在会话中有效，当连接会话结束后在一个心跳周期后会将它删除掉，还有一个需要注意的地方就是临时节点是不可以有子节点的\n```\ncreate -e /temp temp\nls /\n```\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13q0mlvgj20hc02cglu.jpg)\n\n接着我们`ctrl + c`结束客户端控制台，等待个几秒钟在继续进行连接\n\n```\n./zkCli.sh\nls /\n```\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13q932cmj20jk020aa8.jpg)\n\n接着临时节点就已经木有了，还有一个节点类型，就是有序节点，有序节点不需要你给它指定它的序列编号，会自动生成，例如\n```\ncreate -s /seq seq01\nls /\n```\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13qkp20hj20n803kwf4.jpg)\n\n你们的应该会是从0开始为什么我的是从4开始呢？因为我用的Docker跑的CentOS挂载了虚拟卷QAQ所以之前的记录也还是在的，无伤大雅，我们继续，接着给它创建一个子节点\n```\ncreate -s /seq0000000004/cs children01\nls /seq0000000004\n```\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13qvvko1j20uw03u3z8.jpg)\n\n创建说完了，接着如何查询一个节点的信息呢？例如我们指定的value，很简单使用get命令即可\n\n```\nget /a\n```\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13r4f95yj20k80asjsr.jpg)\n\n可以看到返回了一串信息，分别介绍下\n\n```\n// 这个地方是value\na\n// 事务ID号\ncZxid = 0xd\n// 事务发生时间,也可以理解为创建时间\nctime = Wed Jul 04 15:11:09 UTC 2018\n// 最后修改的事务ID号\nmZxid = 0xd\n// 修改发生时间\nmtime = Wed Jul 04 15:11:09 UTC 2018\n// 添加或者删除子节点操作的事务ID👌\npZxid = 0xe\n// 当前节点的版本号\ncversion = 1\n// 当前节点数据的版本号\ndataVersion = 0\n// ACL版本号\naclVersion = 0\n// 这个默认都是0，只有临时节点有，如果是临时节点，这里显示的是临时节点的会话ID\nephemeralOwner = 0x0\n// value 长度\ndataLength = 1\n// 有多少个子节点\nnumChildren = 1\n```\n\n查询说完了，接我们来说下如何修改节点，也很简单利用`set`命令即可\n\n```\nset /a aa\nget /a\n```\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13rgksnhj20o80b075q.jpg)\n\n可以看到修改时间和数据版本还有value都发生了变化，为什么这里要记录version呢？因为ZooKeeper面对并发写入情况下采用的是乐观锁的概念。\n\n接着说一下如何删除一个节点，利用`delete`命令但有一个要注意的地方就是，要删除的节点必须没有子节点，否则你就要先从该节点的子节点删起\n```\ndelete /a\n```\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13rqpupuj20lc024dg4.jpg)\n\n看直接就提示了，该节点不是用空节点\n```\nls /a\ndelete /a/aa\ndelete /a\nls /\n```\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13s02audj20lc04cq3u.jpg)\n\n已经删除掉了，更多的命令可以使用`help`来查询，接着我们来说一下集群，但在集群之前，先来说一下那个配置文件，还记得之前那个`zoo.cfg`嘛？接着先说说它，拿几个默认的出来说说\n\n```\n// 心跳维持时间，每个tickTime间隔就会发送一次心跳\ntickTime=2000\n//集群中fllower服务与leader服务器之间最长心跳时间 initLimit * tickTime\ninitLimit=10\n//集群中leader和fllower之间发送消息请求和应答最大时间长度 syncLimit * tickTime\nsyncLimit=5\n// 客户端连接端口\nclientPort=2181\n// 数据存放目录\ndataDir=/tmp/zookeeper\n```\nOK，接着说说ZooKeeper的集群\n\n## 分布式搭建\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13sl1opfj20p80j0tb9.jpg)\n\n这便是ZooKeeper的集群结构了，从图上可以看到有三个角色，分别是 Leader、Follower、Observer，在理解这些角色之前我们要先知道ZooKeeper是依赖ZAB协议来实现分布式下的数据一致性算法，ZAB算法是一种专门为ZooKeeper设计的一种支持崩溃恢复的原子广播协议，基于该协议ZooKeeper实现了一种主备模式的架构来保证分布式下的数据一致性，在分布式环境下，所有的事务操作(例如创建和修改)都会交给Leader来实现，其它的Follower也只负责转发，所有的非事务操作自然就交给Follower是不是有点像数据库的读写分离？那这个Leader和Follower是怎么配置和设定的？这个不需要设定，ZooKeeper对主从有几种选举机制，就算在集群环境中Leader节点挂了也会立马从Follower节点中选举出一个Leader来，具体的选举算法，我留在下一篇，下一篇我们来聊聊ZooKeeper的一些原理，接着来说说Observer这个角色，这个角色比较特殊，因为它只负责在不影响集群事务处理能力的前提下来提升集群的非事务的处理性能(如何处理的也放在下一篇原理篇)，说了一堆概念，接着我们来说说ZooKeeper的集群环境搭建\n\n首先我准备了3台CentOS的机器，我是使用Docker搭建的环境，推荐大家也使用，当然大家用本机或者虚拟机都是可行的，环境而已无所谓。\n\n首先修改各自下面的`zoo.cfg`文件\n添加内容如下:\n```\n// 格式为 IP or HOST + Port1 + Port2\nserver.1=centos_centos1_1:2333:3333\nserver.2=centos_centos2_1:2333:3333\nserver.3=centos_centos3_1:2333:3333\n```\n来说一下，IP or Host这个我就无需解释了，port1也就是第一个端口是Leader和Follower之间的通信传输端口，port2也就是第二个端口是主机间选举Leader时使用的接口，接着我们在各\n\n接着我们去各个主机的dataDir目录下去创建myid文件，其内容为各自节点ID\n\n第一台主机\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13t7l2ltj214i0n2t9c.jpg)\n第二台主机\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13tgbja6j20vy0kk0t6.jpg)\n第三台主机\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13tlirbjj20qo0hkq38.jpg)\n配置完成，接着启动来看看\n启动后接着来看看它的日志文件，就在bin目录下`cat zookeeper.out`\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13u0jlptj21460i2ted.jpg)\n发现虽然是启动完成了，但是抛了一个异常，这个不用太在意，是另外2台机器还没有启动起来，接着把他们分别启动，OK都启动后，我们分别使用他们的客户端连接Server\n\n```\n./zkCli.sh \n```\n\n接着我分别执行\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13ujeukqj21z00v0nkp.jpg)\n\n可以发现我们之前插入的数据也被同步到各个节点了，接着随意在一台机器上插入数据\n```\ncreate /a cc\n```\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13usyu85j21ym092dyr.jpg)\n那如何知道我这台机器是Follower还是Leader呢？使用`bin`目录下的`zkServer.sh`\n```\n./zkServer.sh status\n```\n第一台机器\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13v3ekljj20nk03mgm8.jpg)\n第二台机器\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13vbec6lj20og05amy9.jpg)\n第三台机器\n![](http://ww1.sinaimg.cn/large/7fd2951agy1ft13vljfr9j20qm04egmd.jpg)\n\n可以看到这些数据都有一个`mode`的属性，这个mode的值即指明了当前谁是follower谁是leader，集群搭建就到这里，下一篇说ZooKeeper的一些原理的时候还会再细写\n\n\n## 使用场景\n\n简单举几个例子，范围太广了\n\n**负载均衡**\n\n通过ZooKeeper的负载均衡可以很好的通过ZooKeeper来做到负载均衡，例如我们的节点都是注册在ZooKeeper上，那么我们就可以根据ZooKeeper下节点的使用情况来自定义负载路由算法，最常见的使用场景也就是 Dubbo + ZooKeeper 、Kafka\n\n**注册中心**\n\n还需要解释么，而且利用其临时节点的特性非常好实现，众所周知，ZooKeeper的临时节点在其会话断开时会在一个心跳周期内将其干掉~\n\n未完待续，敬请关注下一篇：《ZooKeeper的一些原理，了解一下》\n\n如果你觉得作者写的这篇文章对你有帮助或者收获很大的话，你可以尝试着请我喝一瓶《东方树叶》或者吃一块《\u001d鸡胸》来激励我！！！\n\n**微信请客**\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmntt0mzpj20yi1auaki.jpg)\n\n\n**支付宝请客**\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnun44gdj20go0p00y2.jpg)","cover":"","link":"zookeeper_base.html","preview":"\u003cp\u003eZooKeeper来初步了解一下？\u003c/p\u003e\n","title":"ZooKeeper来初步了解一下？"},{"content":"\n首先，我先列个大纲目录，简明扼要的说明一下这一篇文章要写的内容是啥\n\n* 迷宫入口的宏观结构\n* 入口的背后\n* 容器中获取一个bean的背后\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnddn4zbj204z05rdgg.jpg)\n\n## 迷宫入口的宏观结构\n\n嗯，迷宫，迷宫的入口是什么？标题说的很明确，是使用Annotation的方式来注册和注入，那么我分析的入口就是`AnnotationConfigApplicationContext`，那么入口有了，但是并不准备直接从这个迷宫走进去。\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmne2c253j20b40b4abf.jpg)\n\nSpring结构还是清晰有序中透着复杂，直接闯像我这种闯迷宫已经好多次的“老司机”到是能来去自如，但是新司机怕不是要晕头转向，所以明人不说暗话，我要看图，没图说个XX\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmneeocm5j22hc0uqacb.jpg)\n\n不要慌，虽然结构复杂，但只关注主要的，其它的也就自行不攻而破所以不慌！\n\n已知`ApplicationContext`一个顶层的`Context`接口，然后它的顶层是继承的`BeanFactory`，`BeanFactory`是什么它主要负责什么？我这里就简而言之，它就是一个Bean工厂的接口规范，通过实现这个接口外部可以从工厂中获取一个`bean`\n\n接下来我们再来说一下`HierarchicalBeanFactory`和`ListableBeanFactory`\n\n\n**HierarchicalBeanFactory**\n\n简而言之就是一个用来层次化工厂的，其中就主要定义了2个接口方法`getParentBeanFactory`和`containsLocalBean`，方法名就很顾名思义，如果还是不懂没关系，这个类对于本文来说不重要\n\n**ListableBeanFactory**\n\n也简单描述吧，首先这个接口定义的接口方法大体范围意义就是获取`BeanDefinition`一些根据Annotation和根据类型获得一些Bean类型属性，那所谓的`BeanDefinition`又是个什么鬼东西？那这里先来简单的介绍一下，无论你是从XML配置文件中使用`\u003cbean name=\"....\" class=\"...\"\u003e`还是使用注解的方式注册一个Bean都会被当做一个`BeanDefinition`存储起来\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnfis70hj20c80c8go3.jpg)\n\n不多哔哔，接下来再来看`ApplicationContext`作为一个顶层的Context接口总还是会有牌面的定义一些东西的，里面啊首先就是一堆context的属性获取当前context的id啦，什么ApplicationName啦，启动时间啦，获得父Context啦，但里面定义了`getAutowireCapableBeanFactory`(突然严肃)，这个工厂也是个接口里面定义着配置Bean、创建Bean、销毁Bean和自动装配，简单点来说它就是一个定义着创建bean和注入bean的一个工厂接口，这样说OK嘛？里面还有一点细节我就不补充了\n\n往下走，我们再来稍微关注一下`ConfigurableApplicationContext`接口,这个接口顾名思义就是一个定义了配置`ApplicationContext`的接口里面定义了些许接口方法，但暂时并不需要关注那么多，记住`refresh`和`getBeanFactory`方法即可，现在不同这2个方法是干啥用的都没关系，你先记住，待会你就知道了。\n\n接下来越来越近了，终于看到了一个不是接口的抽象类`AbstractApplicationContext`，这个类细节很多，但不用慌，只需要关注我本文所提及即可，仅从本文的角度出发，该抽象类实现了`BeanFactory`的`getBean`方法，而这些`getBean`的实现内容都是通过`getBeanFactory().getBean(...)`来实现的，并且实现了一个`refresh`方法，请一定要记住这里实现了`refresh`，它里面实现了啥，都先不要管，记住就行，本文后面会回到这个方法来的。\n\n\n接着是`GenericApplicationContext`我们仅关注主要的(与本文相关的)，该类会在实例化的时候就会创建一个`DefaultListableBeanFactory`的`beanFactory`属性存起来，之前定义个`getBeanFactory`实际上返回的就是此处的`beanFactory`,其中还有一个关键的方法就是`registerBeanDefinition`\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmngbqyxqj20y805uab2.jpg)\n\n实际上也是调用的`beanFactory`的`registryBeanDefinition`它的实现细节不管，马上就要介绍了，因为接下来就是入口的背后小节了\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnglkghij206804ymy2.jpg)\n\n\n## 入口的背后\n正式发车，首先来看下如何使用长什么样子？\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnh0jmzyj20c80c8q5f.jpg)\n\n```\nApplicationContext applicationContext = new AnnotationConfigApplicationContext(\"base packages..\");\n\napplicationContext.getBean(\"....\")\n```\n\n大致就是这样玩的吧，首先很关键在`new AnnotationConfigApplicationContext`时发生了什么\n\n\u0008![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnhja9c4j20ua04mdge.jpg)\n\n先简要说明各自的作用我们在细入从中，所谓从宏观到微观，可能微观中又透入着宏观，道法自然，顺气自然。\n首先`this()`，调用了自身的无参构造函数\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmni7whcjj20rq03k3zd.jpg)\n\n实例化了2个属性，只需要关注`scanner`属性即可它是扫描ClassPath下的BeanDefinition的\n接着是`scan`方法\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnih1xnfj210k03wwfe.jpg)\n\n这个方法就是去调用了`scanner.scan`方法将外部传入的要扫面的`basePackage`给传了进去，接着来看下`scanner.scan`方法\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmniq6ckrj20vm0a40us.jpg)\n\n其中也只要关注`doScan`方法即可，它才是幕后主使\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmniztsofj219i0m07ao.jpg)\n\n首先老套路遍历传入的basePackages，挨个搜索，暂时只需要关注`findCandidateComponents`它会根据遍历的每个basePackage去定位出所有需要注册的BeanDefinition来简单看下\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnj8xhhuj20xc07gabm.jpg)\n\n没什么好说的直接看`scanCandidateComponents`\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnjhyufoj21440kiq6q.jpg)\n\n直接聚焦到这个方法中最核心的2段来看下，就是由这里来判断是否有要注册的`BeanDefinition `而`inlucdeFilters`中在该类实例化时就会被默认的添加`Component`注解，所以默认在这里所有`Component`注解都会被注册\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnjqta2aj20zi0bg0ur.jpg)\n\n接着回来剩下的那一句判断就更加简单了\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnjyj5b5j212004m75f.jpg)\n\n最后一个判断看方法名都能看出来，就不用再多解释了吧。。。还是简单解释一下吧(皮这一下很开心)，首先类必须不是一个接口其次可以被子类重写，通过条件的就会被add进去最后返回，\n再度回到`doScan`\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnkdx5y7j219i0lmagi.jpg)\n\n然后在此处获得`beanName`然后将拿到的所有`BeanDefinition`封装成`BeanDefinitionHolder`,其实这里也是封装了一下，将`beanName`和`alias`还有`beanDefinition`封装了进去最后再调用`applyScopedProxyMode`\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnknz5ulj214a09g0v0.jpg)\n\n这里我们这样使用默认是使用的`NO`所以直接返回没什么好说的(PS: 其实我是想说一下的，这\u0008里还是有点道道可以说的，日后有机会再说吧对于这里暂时不重要~~)\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnlkhim4j20jg0d6422.jpg)\n\n最后在`doScan`中调用`registerBeanDefinition`完成注册\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnluv8w1j218802ymxw.jpg)\n\n我们接着来看这个`registerBeanDefinition`干了什么\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnm31sfhj21320dkacp.jpg)\n\n实际上还是调用了`AnnotationConfigApplicationContext`的`registerBeanDefinition`方法再把`BeanDefinition`传递了过去，我们回到`AnnotationConfigApplicationContext`来看\n`registerBeanDefinition`,你会发现并木有，还记得它是继承什么类来着吗？没错`GenericApplicationContext`它里面定义了而它又是调用`beanFactory`的`registerBeanDefinition `方法所以直接看`beanFactory`的`registerBeanDefinition `方法就可以了\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnmb8k46j20zi05awfr.jpg)\n\n别的不管专注于这三句即可，实际上就是定义了一个`Map`一个`List`将它存储起来，`scan`分析完了，有没有发现那里不对现在还只是个`BeanDefinition`不是一个实例啊不能注入啊有木有，当然了因为还没有分析完，我们在回到`AnnotationConfigApplicationContext`这里来\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnmkan1rj20so04waam.jpg)\n\n因为还有一个`refresh`方法没有讲啊，它这里也是直接调用`AbstractApplicationContext`中的`refresh`方法，从本文的前文中就一直提醒读者记住这个方法，说之前先已知一件事情，就是在默认情况下所有的`bean`实例化都是单例的和非懒加载，OK现在就是时候来说一下它了，它可是一个至关重要的方法\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnmshsjcj208c08c75p.jpg)\n\n里面调用了很多个方法来完成这件事，实际上`refresh`方法就是初始化容器用的它为IOC容器准备了Bean生命周期的管理条件听不懂没关系，我们只关注它其中很小的部分，还记得我说的已知嘛？时候贴代码了\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnn3uwy6j210w0g276n.jpg)\n\n只关注这一句即可，实例化所有单例的非懒加载的bean，迷宫快走到头了，来我们来看看它究竟是何方神圣\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnnb89usj21hc0p60zr.jpg)\n\n不听不听🙉，我们只关注`beanFactory.preInstantiateSingletons()`即可，继续来看这个`beanFactory.preInstantiateSingletons`做了什么\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnnkentlj218a0tktfw.jpg)\n\n实际上这里调用的就是`scan`注册的`beanDefinitionNames`有木有啊，然后将它挨个循环出来然后调用`getBean`\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnnsp2vrj215i0nm0xt.jpg)\n\n他这里调用了它的父类`AbstractBeanFactory`的`getBean`\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmno23dbdj20vm03waau.jpg)\n\n然后在继续来看`doGetBean`里干了啥，代码很长只用关注必要的即可\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmno9mkswj213s0e8mzr.jpg)\n\n还记得我们已知的条件吗？`bean`默认的作用域是单例的,所以看这里，这里实际上是先去调用了`AbstractAutowireCapableBeanFactory`的`createBean`方法，同理我们也只需要关注这其中需要关注的点即可\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnojaoy7j211u070wfm.jpg)\n\n注意了，这个方法里面的细节还是比较多的，我仅简要说明让大家理解即可\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnorl8tjj20z00o0aer.jpg)\n\n接着先看它的`createBeanInstance`方法，直接看到它的最后一行，一般来说也是最常用的，使用无参构造函数来创建一个实例\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnpggpotj20pq02i74j.jpg)\n\n接着来看`instantiateBean`做了啥\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnpoa39rj217s0hujvd.jpg)\n\n此处就是获取一个实例化策略，然后在调用`instantiate`来进行实例化，这里我们还是已最常用最简单的`SimpleInstantiationStrategy`的`instantiate`来说\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnpy0gumj219w0qwwkt.jpg)\n\n这里实际上会去调用`BeanUtils.instantiateClass`另一种CGLIB的方式在简单的实例化策略中是不支持的\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnq7y0roj210404kaah.jpg)\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnqcfbbqj21e402mt9p.jpg)\n\n接着来看`BeanUtils.instantiateClass`\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnqkss5yj21ea0h0wja.jpg)\n\n没什么好说的，就是直接通过反射创建实例，接着继续回来\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnqsusdvj21100dktb5.jpg)\n\n`createBean`之后会调用的一个`getSingleton`方法，并将创建的`bean`实例传递进去，这个方法比较长，直接看关键点\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnr0va3yj20qm03oq39.jpg)\n\n对于新的实例都会调用一个`addSingleton`方法来看下\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnr9oilhj20vk07iwgb.jpg)\n\n实际上很简单有木有，就是还是定义了一个Map将实例化的对象存储了起来，再继续回到`doGetBean`来最后将`bean`返回回去，简单的来说`doGetBean`如果实例是单例的，如果没有被实例化过就会帮你实例化一遍，否则就直接获取返回\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnrlzuttj20pk02qjri.jpg)\n\nOK容器的里bean的初始化都已经ok了，那我`Autowire`的对象是如何注入的呢？实际上在调用`doCreateBean`中有一个关键的点就是这一段\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnrv3typj21cs0fywiv.jpg)\n`if (earlySingletonExposure)`会将所依赖的还未初始化的`bean`先给拿到并进行优先初始化，然后再通过`populateBean`去填充我们所要注入的`value`，OK，很简单的几句话就把注入的思路给说明白了，如果要具体到里面的细节又是好多道道，这里我已经把源码中注入的思路写明白了，具体细节自个去看吧\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmns9594zj20b40b4adp.jpg)\n\n接下来最后一个小节\n\n## 容器中获取一个bean的背后\n\n这个小节还用写么，不就是调用`getBean`?\n```\napplicationContext.getBean(\"xxxx\")\n```\n还不懂的自个去复看第二个小节~~~\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnsv3ezgj20jg0jgq87.jpg)\n\n为了更好的理解，我还写了一个炒鸡简单的实现了一个Spring的demo，有兴趣的可以[点我](https://github.com/yuequan1997/simple-spring)了解一下，顺手可以给个`star`\n\n本文完\n\n如果你觉得作者写的这篇文章对你有帮助或者收获很大的话，你可以尝试着请我喝一瓶《东方树叶》或者吃一块《\u001d鸡胸》来激励我！！！\n\n**微信请客**\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmntt0mzpj20yi1auaki.jpg)\n\n\n**支付宝请客**\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fsmnun44gdj20go0p00y2.jpg)","cover":"","link":"spring_init_ioc.html","preview":"\u003cp\u003e浅谈使用Spring Annotation容器注册与注入\u003c/p\u003e\n","title":"浅谈使用Spring Annotation容器注册与注入"},{"content":"\n分析Class文件的源码如下：\n```\npackage org.yuequan.klass;\n\npublic class Foo{\n    private int m;\n\n    public int inc(){\n        return m + 1;\n    }\n}\n```\n笔者使用JDK1.8将源文件编译成class文件，为了更好的手动分析这个class文件，笔者将使用现有的Class分析工具去打开这个class文件。\n\n打开后的Class文件:\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3jruhokj20qw0g2jv9.jpg)\n\nJava虚拟机规范对Class文件结构做了严格的规定，其中的字节严格的按顺序紧密的排在一起，中间没有任何的分隔符和其它数据\n\n分析之前先把Java虚拟机规范对Class文件结构的定义先列出来\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3ksvs0jj20qm0fw414.jpg)\n\n根据Java虚拟机规范所描述的Class文件结构，我们大致的可以理解类型分别为u1、u2、u4、cp_info、field_info、method_info、attribute_info，其中u1、u2、u4分别为1、2、4无符号整型字节，_info后缀结尾的都是表结构类型\n基本的介绍的差不多了，那就正式开始分析吧。\n \n- - - -\n根据ClassFile文件结构来分析，前面4个字节是魔数，魔数为固定的`0xCAFEBABE`，魔数可以作为一个文件的特殊识别，很多类型的文件，都会在文件前面加几个字节填充魔数，利用魔数来识别文件类型，根据Java虚拟机规范也只有`0xFAFEBABE`魔数的文件才能被Java虚拟机所接受。\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3lh3931j20ra0g6q6u.jpg)\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3lp9v1mj20qk0fyq5k.jpg)\n- - - -\n再紧跟着的是2个字节的次版本号\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3m6fol8j20r00gctcm.jpg)\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3mfgh5nj20qu0g20vd.jpg)\n次版本号为0，次版本号从JDK1.2以后次版本号就没有再被使用而是一直使用着主版本号。\n- - - -\n再紧跟着2个字节的主版本号\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3mshxhvj20ra0gktcn.jpg)\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3n0pyelj20qy0g676x.jpg)\n  我的主版本号为`0x34`为52，正好是JDK1.8的版本号，为了方便观看，笔者将JDK的版本号整理了一个列表供参考\n- - - -\n再接下来是2个字节的常量池数量\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3nb3hjej20r40gk787.jpg)\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3nmi59jj20r00gimzx.jpg)\n我的常量池数量是19个`0x13 = 19`，常量池元素索引是从1开始而不是0这点要注意，所以常量池可用数量为1 - count-1，第0项是为了某些指向常量池的索引值的数据在特殊情况下不需要引用任何一个常量池项目的时候就可以将索引置为0\n\n接下来介绍ClassFile的cp_info也就是常量池，常量池中主要存储字面量和符号引用,字面量的意义比较接近于常量的概念，如字符串、final后的常量值等，这里的符号引用主要还是包括：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符，接下来再看下cp_info的结构定义，常量池中每一项都是一个表，到目前JDK8版本共有14个常量类型的结构，为了区分这些常量类型，常量数据的第一字节是tag分别对应着这14个常量类型\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3ohl0msj20vi0n4whp.jpg)\n- - - -\n概念介绍到这里差不多了，那么开始正式的分析\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3oq5jk3j20ra0ge42f.jpg)\n第一个常量的tag是0x0A对应着10也就是`Constant_Methodref_info`\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3oxck2nj20da05ejrq.jpg)\n根据结构后面还有2个u2类型的`class_index`和`name_and_type_index`\n`class_index` 是指常量池中索引为`class_index`的常量项，`name_and_type_index`同理，由于后面的常量项还没分析，无法得知index所指的具体值，所以先把值分析出来放在这里吧，不用担心，我在文章的该列出来的地方还会在列一遍，常量池第一项的数据\n```\n// index 1\ntag = 10\nclass_index = 4 \nname_and_type_index = 15\n```\n- - - -\n接着我们来分析第二项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3pv74upj20ra0h6gpj.jpg)\n第二项tag为9对应着`CONSTANT_Fieldref_info`\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3q1l7a2j20ce04gq3a.jpg)\n```\n// index 2\ntag = 9\nclass_index = 3\nname_and_type_index = 16\n```\n- - - -\n第三项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3q8sx56j20rc0goadz.jpg)\n第三项tag为7对应着`CONSTANT_Class_info`\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3qey6aoj20ai03qwem.jpg)\n\n```\n// index 3\ntag = 7\nname_index = 17\n```\n- - - -\n第四项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3qmqa1dj20rc0h0n13.jpg)\n第四项tag为7对应着`CONSTANT_Class_info`\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3r7riowj20ai03qwem.jpg)\n```\n // index 4\n tag = 7\n name_index = 18\n```\n- - - -\n第五项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3ris9wmj20r60gctcm.jpg)\n第五项的tag为1对应着`CONSTANT_Utf8`\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3rrafunj20b804u74j.jpg)\n长度为1\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3rxv3p5j20r20g6jva.jpg)\n长度为1那bytes也就只有一个\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3s5h86bj20rc0gigpj.jpg)\n```\n// index  5\ntag = 1\nlength = 1\nbytes = ['m'] // bytes = [6D]  6D = 109 =\u003e UTF8 =\u003e m \n```\n- - - -\n第六项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3sf5wh1j20r40h8n13.jpg)\n嗯哼tag还是01\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3sqhsqnj20b804u74j.jpg)\n长度为1\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3sxzradj20r80gu42f.jpg)\n```\n// index 6\ntag = 1\nlength = 1\nbytes = ['I'] // bytes = ['49'] 49 =\u003e 73 =\u003e UTF8 =\u003e I\n```\n- - - -\n第七项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3tefqvuj20r40gcq6u.jpg)\ntag还是01\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3tkkfy7j20b804u74j.jpg)\n长度为6\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3tqixvnj20r80gwgpj.jpg)\n```\n// index 6\ntag = 1\nlength = 6\n//  23333 很长于是注释写这里\n// [0x3C, 0x69, 0x6E, 0x69, 0x74, 0x3E]\n// to UTF8\n// ['\u003c', 'i', 'n', 'i', 't', '\u003e']\n// bytes.toString() =\u003e \"\u003cinit\u003e\"\nbytes = ['\u003c', 'i', 'n', 'i', 't', '\u003e']\n```\n- - - -\n第八项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3tx5ogzj20rm0gkwif.jpg)\ntag仍为01 ，😊2333333\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3u4eg8vj20b804u74j.jpg)\n长度为3\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3uavuqaj20r60gqadz.jpg)\n```\n// index 8\ntag = 1\nlength = 3\nbytes = ['(', ')', 'V'] //不再重复转换步骤拉\n```\n- - - -\n第九项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3ulj05hj20rg0h0q6w.jpg)\ntag还是01哦\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3urro3jj20b804u74j.jpg)\n长度是4\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3uxk9z7j20ri0gm0wo.jpg)\n\n```\n// index 9\ntag = 1\nlength = 4\nbytes = ['C', 'o', 'd', 'e']\n```\n- - - -\n第十项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3v75rczj20rc0hmtco.jpg)\ntag还是01哦\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3vd1k8vj20b804u74j.jpg)\n长度是15\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3vi8bmej20ra0gatcm.jpg)\n```\n// index 10\ntag = 1\nlength = 15\nbytes = ['L', 'i', 'n', 'e', 'N', 'u', 'm', 'b', 'e', 'r', 'T', 'a', 'b', 'l', 'e']\n```\n- - - -\n第十一项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3vqbr8tj20r20h8n13.jpg)\n长度为3\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3vxdd5gj20ri0gktcn.jpg)\n```\n// index 11\ntag = 1\nlength = 3\nbytes = ['i', 'n', 'c']\n```\n- - - -\n第十二项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3w32ensj20rc0g6tcm.jpg)\ntag任然是1\n长度为3\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3wcwbw9j20rk0gsjvc.jpg)\n```\n// index 12\ntag = 1\nlength = 3\nbytes = ['(', ')', 'I']\n```\n- - - -\n第十三项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3wk8jbfj20rm0gq788.jpg)\n长度为10\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3wqwawjj20ra0gitcm.jpg)\n\n```\n// index 13\ntag = 1\nlength = 10\nbytes = ['S', 'o', 'u', 'r', 'c', 'e', 'F', 'i', 'l', 'e'] //SourceFile\n```\n- - - -\n第十四项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3wylvbuj20re0h242g.jpg)\n长度为8\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3x40avwj20ra0gk42f.jpg)\n```\n// index 14\ntag = 1\nlength = 8\nbytes = ['F', 'o', 'o', '.', 'j', 'a', 'v', 'a'] // Foo.java\n```\n- - - -\n第十五项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3xb9mpuj20r80hcwif.jpg)\ntag为12,12对应着`CONSTANT_NameAndType`\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3xjm4orj20dw04yq3c.jpg)\n```\n// index 15\ntag = 12\nname_index =  7\ndescriptor_index = 8\n```\n- - - -\n第十六项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3xqrzg1j20r00gi42f.jpg)\n```\n// index 16\ntag = 12\nname_index = 5\ndescriptor_index = 6\n```\n- - - -\n第十七项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3xwnkfoj20rk0g042f.jpg)\n长度为21\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3y1frpcj20r60g2786.jpg)\n```\n// index 17\ntag = 1\nlength = 21\nbytes = ['o', 'r', 'g', '/', 'y', 'u', 'e', 'q', 'u', 'a', 'n', '/', 'k', 'l', 'a', 's', 's', '/', 'F', 'o', 'o']\n```\n- - - -\n哇，最后一项，由此可见常量池占了我们字节码文件的大部分内容\n第十八项\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3y9ob55j20rc0h8tcn.jpg)\n长度为16\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3yg6juej20re0h0jvb.jpg)\n```\n// index 18\ntag = 1\nlength = 16\nbytes = ['j', 'a', 'v', 'a', '/', 'l', 'a', 'n', 'g', '/', 'O', 'b', 'j', 'e', 'c', 't']\n```\n- - - -\n至此，常量池已经分析完了，是时候整理一波了。\n\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3yml4l3j21jk2yuwzj.jpg)\n大致分析出来的内容用思维导图整理了一下，最终整合一波\n```\n// index 1\n// class_index = 4  name_and_type = 15\nMethodref  java/lang/Object.\u003cinit\u003e\n\n// index 2\n// class_index = 3  name_and_type = 16\nFieldref org/yuequan/klass/Foo.m\n\n// index 3\n// name_index = 17\nClass org/yuequan/klass/Foo\n\n// index 4\n// name_index = 18\nClass java/lang/Object\n\n// index 5\nUtf8 m\n\n// index 6\nUtf8 I\n\n// index 7\nUtf8 \u003cinit\u003e\n\n// index 8\nUtf8 ()V\n\n// index 9\nUtf8 Code\n\n// index 10\nUtf8 LineNumberTable\n\n// index 11\nUtf8 inc\n\n// index 12\nUtf8 ()I\n\n// index 13 \nUtf8 SourceFile\n\n// index 14\nUtf8 Foo.java\n\n// index 15\n// name_index = 7 descriptor_index = 8\nNameAndType  \u003cinit\u003e\u0026()V\n\n// index 16\n// name_index = 5 descriptor_index = 6\nNameAndType m\u0026I\n\n// index 17\nUtf8 org/yuequan/klass/Foo\n\n// index 18\nUtf8 java/lang/Object\n```\n终极整理已完成~，常量池分析就先到这里，由于文章篇幅好像有点长了23333，还有些许知识点我放在下一篇《升级版》中去探讨\n- - - -\n接下来，该分析啥，掏出ClassFile结构来看看\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3yxhab3j20qs0g8415.jpg)\n常量池结束后，紧跟着的是2个字节的访问标识符\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3z5by0wj20r80gi0wn.jpg)\n我们来看看对应着啥？\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3zdv3ttj20wu0hkgph.jpg)\n一眼看上去感觉没有对的上的？ 但使用了`bitmask`的思路所以对应的应该是\n```\naccess_flag = ACC_PUBLIC, ACC_SUPER\n```\n- - - -\n在接着往下分析\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3zl45b6j20po0feq5g.jpg)\n访问标识符完了后，根据结构是2个字节的`this_class` 这个值也是指向的常量池的索引\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3ztd794j20r00g6n12.jpg)\n对应着常量池第三个索引(从1开始数)也就是`org/yuequan/klass/Foo`\n- - - -\n接下来是父类\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi3zzopopj20pe0f2jtw.jpg)\n除`java.lang.Object`以外所有类都有一个默认父类，那便是`java.lang.Object`，可以理解为父要么为0要么就是指向常量池中存在的Class，而为0的根据目前来看应该只有`java.lang.Object`如果还有其它的欢迎在Blog的Github上提issue大家一起分享。\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi4078mbtj20r20g4gpi.jpg)\n常量池索引为4的是`java.lang.Object`,所以该类的父类应是`java.lang.Object`\n- - - -\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi40gwp3pj20qo0fwacr.jpg)\n接下来是接口\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi40tszdoj20r80h0wif.jpg)\n此类没有实现接口数量为0\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi40zcuioj20qq0fy0vf.jpg)\n- - - -\n接下来是`fields_count`,它的数量为1\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi415672uj20r00gaq6u.jpg)\n接着是`field_info`\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi41cw4bdj20qq0fswh6.jpg)\n先把结构掏出来看下\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi41kiur7j20na06cq3p.jpg)\n根据结构先是一个u2的访问标识符\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi41s3m78j20qu0g0ady.jpg)\n`0x0002`对应着`ACC_PRIVATE`\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi41ykzxyj20u00l0jvo.jpg)\n接着是一个u2类型的`name_index`，`0x0005`对应着常量池中cp_info[5]的m\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi42627ecj20ra0fwdjr.jpg)\n接着是u2类型的`descriptor_index`，`0x0006`对应着常量池中cp_info[6]的`I`(int的描述形式)\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi42fbxhfj20r40fwady.jpg)\n接着也是一个u2类型的attributes_count，但数量为0\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi42lnsfqj20r00fwady.jpg)\n- - - -\n接下来的方法的数量\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi42rpg4sj20qm0futbc.jpg)\n数量表示有2个方法\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi42zc6efj20r40fwady.jpg)\n- - - -\n接着是`method_info`，还是先把结构拿出来\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi434cxnrj20mu064752.jpg)\n先分析第一个`access_flags`\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi43dqjoxj20r60g8tcm.jpg)\n`0x0001`对应着`ACC_PUBLIC`\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi43l182lj20u00rw448.jpg)\n第二个是`name_index`，指向着常量池的一个索引\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi43qw31cj20r60h0adz.jpg)\n指向常量池第7个索引`\u003cinit\u003e`\n接着是`descriptor_index`\n![](http://ww1.sinaimg.cn/large/7fd2951agy1fqi43xvaq9j20r00g4jva.jpg)\n指向常量池第8个索引`()V`，由于文章篇幅太长了，剩下的`attribute`改天分解或者说不会再读分解，我感觉已经够了，如果大家想要我写完的话，那我就写完吧","cover":"","link":"class_analysis.html","preview":"","title":"手把手带你分析Class字节码文件"},{"content":"\n本来想写一篇企业级通用的CI/CD但是太麻烦了，涉及的知识点广度较多，我先写个简易的引子吧，以后看有没有机会分享一下近期研究出来的企业级比较通用的`CI/CD`方案，以一个SpringBoot的项目做示例。\n\n\u003e 如果你有什么好的方案的话可以加微信或者邮箱我们共同探讨一下\n\n发布流程如图\n\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprip989p1j21190fgjtm.jpg)\n\n我的服务器环境是\n* CentOS7\n* Docker 18.03.0-ce\n* DockerCompose 1.19.0\n\n本次方案所使用的技术有\n* Docker\n* Docker Compose\n* Jenkins\n\n为了方便,我写做了一个[docker-jenkins](https://github.com/yuequan1997/docker-jenkins)给颗小心心就可以了~\n\n这里演示起见，为了方便我直接使用[GitLab](https://gitlab.com/)的仓库，这样大家都不用去创建自己的Git仓库，可以很快速方便的体验这份简易的持续集成方案，但这样做有个缺点就是如果你没有做内网映射或者是没有单独的服务器的话，你无法使用Git的WebHook访问到你的Jenkins服务器的接口\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fpriroo9clj21f60pqwio.jpg)\n\n创建一个仓库，然后将项目推送至该仓库，这个不用写在文章里了吧，应该都会。\n\n好，开始进入正题，进入正题之前请确保你已经安装了`docker`和`docker-compose`\n首先创建一个`jenkins`文件夹\n然后将我GayHub仓库的`docker-compsoe.yml`下下来，为了方便我已经将镜像提交到了Docker仓库，如果你没有配置加速或者其它的一些方式的话，你可以自行下载`Dockerfile`文件进行`build`\n\n```\nmkdir jenkins \u0026\u0026 cd jenkins\n\nwget https://raw.githubusercontent.com/yuequan1997/docker-jenkins/master/docker-compose.yml\n\ndocker-compose up -d\n```\n\n使用`docker ps`检查下容器运行起来了没有\n\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprisnkuuqj21xm02iq3r.jpg)\n\n然后\n```\ndocker logs 容器ID\n```\n注意我红色框起来的区域，如果没有的话，也没有出现异常的话，请等待一下，然后复制那一串加密的字符\n\n如我的是：`61cfaad2c6a94b7ebb54deafac051150`\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fpritgx6tuj21sw0t8tgn.jpg)\n打开浏览器输入：`http://服务器IP:8080/`我在`docker-compose.yml`文件中配置了端口是8080的映射如果你的被占用或者你想更换端口的话，请自行更改\n\n将复制的那串秘钥贴进去，点继续\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fpriubnetvj21l60xa431.jpg)\n\n直接点这个\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fpriv6fpxej21oc0zcn45.jpg)\n\n等它安装完,同时你也可以使用`dokcer logs`命令来查看当前运行的控制台\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprivg5n4pj21pu0ywn24.jpg)\n\n创建一个账号\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprivov7wkj21ii0uin0f.jpg)\n\n然后进入控制台，系统管理=》管理插件，然后选择可选插件，安装以下插件，利用右上角的过滤\n* Publish Over SSH\n* Gitlab\n* Gitlab Hook\n* Maven Integration\n\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fpriw2hpauj21ea0j2q57.jpg)\n安装好以后，回到控制台，新建一个任务\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fpriwe1orxj21z20rwdkg.jpg)\n\n因为我项目是使用maven构建也安装了maven插件，所以直接选\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fpriwu4k7gj21tc0tmwlv.jpg)\n\n在General选项中，我配置了保留10个旧的构建\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprix74wftj21jw0w642q.jpg)\n\n配置你的Git仓库\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprixkdbs0j21fk0ogtbs.jpg)\n\n构建触发器选这个\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprixvbpj4j21js0t4tdn.jpg)\n\n然后点高级,这里生成了一个秘钥，然后只允许master分支触发Webhook构建\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fpriy6avvgj21my0rugqn.jpg)\n\n然后配置build,它会询问你的maven配置这时候点链接进去配置一下\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fpriyhmrtpj21lo0dmq4o.jpg)\n\n我这里为了简单，没有去配地址，用的自动安装，如果不想自动安装可以去掉这个选项然后输入MAVEN_HOME就可以了\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fpriyz9o2qj21fs0fejsr.jpg)\n\n配置好了后回来,我的配置内容如下，我是使用了`docker-maven-plugin`插件来做的镜像编译和推送\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fpriz9c6tsj21fy0ak0tp.jpg)\n\n我的pom.xml插件配置如下\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprizjhlibj213m0isjvd.jpg)\n\n然后设置\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprizs268xj21fc09ijsi.jpg)\n\n添加一个\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprj035ge5j21o00ki41k.jpg)\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprj0amj1nj21fa0s00x1.jpg)\n\n= = 去系统管理=》系统设置，添加个SSH Server\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprj0lzok8j21e60m4jt9.jpg)\n\n先进入`Docker`容器内生成执行`ssh-keygen`生成SSH秘钥对，如果你确定要用这套流程的话，请将`~/.ssh`挂载，不然每次重启都会丢失 = =\n```\ndocker exec -it 容器ID bash\nssh-keygen\n```\n然后再将生成的公钥加到你的应用服务器中去，然后再到应用服务器下创建一个目录为`releases`\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprj17q075j21f20rogow.jpg)\n配置完后可以点击Test Configuration进行测试\n\n设置完后继续回到任务中进行配置\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprj1mg8oej21bc0ncgov.jpg)\n\n我应用服务器的deploy.sh脚本内容如下\n```\ndocker pull registry.cn-hangzhou.aliyuncs.com/mitchell/eureka-server:latest\ndocker stop eureka-server\ndocker rm eureka-server\ndocker run --name eureka-server -p 9001:9001  -d registry.cn-hangzhou.aliyuncs.com/mitchell/eureka-server:latest\n```\n\n然后保存后进行Gitlab的WebHook配置\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprj22ssd7j21420rwgqv.jpg)\n\n配置这里\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprj2bchacj21ka0amtal.jpg)\n\n这里的内容填\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprj2kcmhzj21mg0cy0uz.jpg)\n和\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprj2s15ooj21fu0340t2.jpg)\n\n填好后点add WebHook添加成功\n接着，我用的是Docker镜像推送，我需要在jenkins的宿主机中去登录一次我Docker的私有仓库，然后在修改下`docker-compose.yml`文件将`/root/.docker/config.json`映射到jenkins容器中去，镜像才能推送到我的仓库中去，否则会没有权限，因为`docker-maven-plugin`1.0的版本以后会默认的去读你的Docker配置，来进行仓库的推送，这里我演示是用的阿里云的镜像仓库，如果不想自己搭的话也可以去使用阿里云。\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprj35laizj20rk0hiq4q.jpg)\n\n我推送到master分支，如果你是内网的话 = = git访问不到你的jenkins机器的话，你自己点立即构建\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprj3jnvedj21xo0peaev.jpg)\n开始了自动构建\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fprj3vr4laj21wm0r4wq3.jpg)\n等它构建完就可以了~~\n\n还有一些改进的地方，将maven的仓库映射宿主机上去，这样每重启就不用再重新下包了，该流程是一个很简易的流程给大家一个引子但也满足一些需求，想要更加灵活能更加响应复杂的业务场景的话，可以去了解`jenkins pipline`和`salave`这个就不在文中提及了涉及知识的广度会比较多","cover":"","link":"simple_ci_cd.html","preview":"","title":"简易的持续集成方案，SpringBoot+Docker+Jenkins+Gitlab"},{"content":"\n\n数据竞争是指多个线程同时对内存的同一块数据或者会共同操作的数据(可能不是放在内存中的数据)进行了操作，只要有一个线程对其进行了写操作就会发生数据竞争\n\n竞态条件指的是程序的执行结果是依赖执行线程执行的顺序，其执行过程会出现其它线程执行的顺序的不同而导致执行结果导致偏差，举三个例子：\n\n1.有竞态条件但无数据竞争\n```\n//获取库存数量\nlock.lock();\nint count = getInventory(merchandiseId)\nlock.unlock();\n\n//库存大于等于购买\nlock.lock();\nboolean isBuy = count \u003e= purchaseQuantity;\nlock.unlock();\nif(isBuy) {\n  //生成订单\n  lock.lock();\n  //库存-1\n  lock.unlock();\n  //出库......\n}else {\n  throw new MerchandHungerException(\"库存不足\");\n}\n```\n\n以上代码在多线程执行时并不会出现数据竞争，因为不会有多个线程同时对数据进操作，所以对数据的操作都只会有一个线程，但其任然是存在竟态条件的，因为这些共享数据还是会在该线程没有持有锁的情况下会被其它线程修改，导致当前获得的状态是失效的，这种会被线程间执行顺序影响的就是竞态条件\n\n2.有竞态条件有数据竞争\n\n例如一个库存出库系统，商品只有一件了，但同时有2个用户(A用户、B用户)都想要够买这一件商品，于是都加入了购物车都同时点击了结算，代码如下：\n\n```\n//获取库存数量\nint count = getInventory(merchandiseId)\n//库存大于等于购买\nif(count \u003e= purchaseQuantity) {\n  //生成订单\n  //库存-1\n  //出库......\n}else {\n  throw new MerchandHungerException(\"库存不足\");\n}\n```\n执行的顺序可能如下\n![](https://ws1.sinaimg.cn/large/7fd2951agy1fp5tbiwn7sj219808ijs1.jpg)\nB用户获取的库存，在执行评断的时候其本身获取的数据已经是失效的了，也有可能2个线程间执行的顺序还会更加的不同，这种执行时会受到其它线程间执行的顺序的影响就称为竟态条件\n\n3.无竞态条件有数据竞争\n```\nMerchanddis merchanddis = getMerchanddis(merchandiseId);\nsychronized(this) {\n  //获取库存数量\n  int count = getInventory(merchanddis.id);\n  //库存大于等于购买\n  if(count \u003e= purchaseQuantity) {\n\t//库存-1\n  }else {\n\tthrow new MerchandHungerException(\"库存不足\");\n\treturn;\n  }\n}\n//添加商品已拥有\nhadMerchanddis.add(user, merchanddis);\n//生成订单\n//出库......\n```\n上述代码已经不会出现竞态条件因为，不会受到其它线程执行的顺序而导致其自身运行结果的正确性，但其仍然存在数据竞争即`hadMerchanddis.add(user, merchanddis);`该数据操作还是会被多个线程同时`add`但当前执行线程不会受到其它线程执行顺序的影响。\n\n竞态条件和数据竞争的区别：\n\t数据竞争主要指的是同一块数据会被多个线程同时操作，被多个线程同时操作时有一个或多个线程写了就是数据竞争。\n\t竟态条件主要指的是当前线程的执行顺序的结果，会被其它线程执行顺序的结果所影响。","cover":"","link":"数据竞争与竟态条件及区别.html","preview":"","title":"什么是竞态条件？什么是数据竞争？"},{"content":"\n\n## 并发\n\n并发？到底什么是并发？我也时常在问自己，什么是并发，但当我想到了现实生活中一个不太可能的例子以后，我想明白了，究竟什么是并发，这是人造的概念但规律却仿佛是神造的一般(指的产生的自然规律)，在许多方面我们既是人也是神，假如有3个人去买票，售票员只有一人窗口也只有一个，这是一个排队机制还没有发现的年代，没有排队机制，给三个买票的人都取个名字，分别叫A、B、C，A要买票去北京，B要买票去上海，C要买票去杭州，于是都在柜台同时说了出来，于是面对这三个人，售票员只能选取一人进行下一步操作，于是说B你要买几点的票？B说我要买8点的票，这时候售票员又记起来还有AC，这时候又问A你要买几点的票A也说是8点，这时候售票员又问C你要买几点的票，C也是同样说道要买8点的票，在得知了这些消息后售票员又想起了B要买8点去上海的票，还没有查询，于是马上又把B8点前往目的地的票价告诉了他，于是分别想起了A、C要买票的事情，分别查询将票价告诉了他们，然后各自掏钱，售票员可能先收B的钱，然后再去收C的钱然后再收A的钱然后给A出票然后再给C出票再给B出票\n\n我自己觉得我比喻的非常形象，比喻始终是比喻，落地到实现，来聊聊计算机的多线程并发执行\n\n在单核情况下程序计数器这个寄存器只有一个，而同时在上面执行的也只有一个这个寄存器，这个寄存器好比我比喻描述的售票员，只有一个，同时能再它上面的指令也只有一条，这时候有程序运行了向操作系统申请了资源放入了内存，运行起来产生了进程，假设这个进程中有三个线程(可能更多，仅是比喻)，分别是A、B、C线程，这些线程也是有各自的程序计数器用于标识当前线程执行的指令，在比喻中就相当于A、B、C所说的话，3个线程都想执行也没有任何同步机制的情况下，由线程调度器来调度执行，具体调度器具体调度算法，仅做比喻，线程A执行了1条指令于是马上被线程B执行了1条指令马上线程C执行了一条指令，也可能是先执行了线程A，任何线程B、C进行的交替执行，比喻中售票员想起B要买8点的票时，得要去帮B去查询执行，但是执行操作的前提是不是要先想起来B要买8点的票的这个上下文，这也就是线程的上下文切换，需要把之前线程执行的上下文又重新加载进来，综上所述这是计算机上在执行线程上的一种并发\n\n上面又太细粒度，我在概念上在粗粒度的描述下什么叫做并发，并发实际上就是多个任务想要在同一时间上去执行，发出了委托，但实际上的执行可能是交替的也可能是并行的或者某个任务又是没有回应的，想要同一时间去执行即为“并”，同一时间发出的执行即为“发”\n\n## 并行\n\n并行是什么？到底什么是并行？先做个比喻，我们有5个人想要同时的通过一道门（可以容纳6个人并排通过），于是我们并排走在了一起，一起通过了这条门\n\n假设我们有5个线程同时在CPU上执行那么即意味着我们必须得拥有6个核（没有5个核的CPU，当然这是人造的，你说要去造一个5核CPU也无可奈何，单核单线程的处理器情况），各个核同时对每条线程执行，即像比喻中的并排走在了一起，一起即为为“并”，行为乃至“行”\n\n## 区别\n\n并发是同时发生的状态它的对立面既是应对，应对的对立面既是发生，而并行是属于同时执行的一种运行机制","cover":"","link":"并发与并行的以及区别.html","preview":"","title":"并行和并发以及区别"},{"content":"\n在上一篇说了`DefaultListableBeanFactory`这个类，本篇将会分析它的一个子类`XmlBeanFactory`，老规矩先看看它的类关系图\n![XmlBeanFactory 类关系图](http://ww1.sinaimg.cn/large/006TpURwgy1fngfhctj7kj31bo0lm77l.jpg)\n\n2333，忽略它已经被废弃了，虽然被废弃了我个人感觉还是很有必要从该类入手的，根据类关系图很直接它继承至`DefaultListableBeanFactory`，现在来看下该类是如何使用的，(^V^虽然大家应该都会用)\n\n```\nResource resource = new ClassPathResource(\"application.xml\");\nBeanFactory beanFactory = new XmlBeanFactory(resource);\nPerson person = (Person) beanFactory.getBean(\"person\");\nSystem.out.println(person != null);\nSystem.out.println(person.toString());\n```\n\n很简单，获取资源文件，将获取的资源文件传入`XmlBeanFactory`，然后再从中获取定义的Bean，接下来正式开始吧。\n\n![XmlBeanFactory 源码](http://ww1.sinaimg.cn/large/006TpURwgy1fngfjg0o40j313q0p47a2.jpg)\n\n根据源码可以发现该类定义了2个构造函数\n\n\n* XmlBeanFactory(Resource resource)\n* XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory)\n\n第一个：该构造函数直接传入`resource`和`null`至另一个构造函数\n\n第二个：`resource`该参数就不用解释了，`parentBeanFactory`该参数代表该`BeanFactory`实例的上一级的`BeanFactory`，不理解没关系，日后会写到的。\n\n首先该构造函数调用了父类的构造函数将`parentBeanFactory`参数传递了过去，然后又调用了`reader.loadBeanDefinitions(resource)`方法，敲黑板！重点在这里。\n\n接着继续往里走\n\n![loadBeanDefinitionReader(Resource resource)](http://ww1.sinaimg.cn/large/006TpURwgy1fngflh8vmkj30z0040gmc.jpg)\n根据代码片段的截图，该方法调用了另一个同名的重载函数\n\n![loadBeanDefinitionReader(EncodedResource encodedResource)](http://ww1.sinaimg.cn/large/006TpURwgy1fngflz6ma3j30n30hfdmn.jpg)\n\n预防资源文件的编码问题，会先将`resrouce`采用`EncodeResource`进行封装，代码很简单想深入查看`EncodeResource`的可以自行去查看源码，到了这里想暂停一下，为了更加系统一点，我们应当先看下这个类的关系结构\n\n![XmlBeanDefinitionReader 类关系结构图](http://ww1.sinaimg.cn/large/006TpURwgy1fngfo31xycj30oe0e00tr.jpg)\n自然从最上面的`EnvironmentCapable`和`BeanDefinitionReader`接口开始\n\n*EnvironmentCapable*\n![EnvironmentCapable 源码](http://ww1.sinaimg.cn/large/006TpURwgy1fngfps9psfj30rk07kt9k.jpg)\n\n该接口用作于环境标识，其只定义了一个接口方法`getEnvironment()`用于获取当前环境，额，应该会有人问我环境吧，去看下Spring的`profile`这个东西，可以利用`profile`来区分生产环境、测试环境、开发环境的配置等，233333扯远的，如果有朋友对这一块感兴趣，可以私下探讨。\n\n*BeanDefinitionReader*\n![BeanDefinitionReader 源码](http://ww1.sinaimg.cn/large/006TpURwgy1fngfr1cbv9j30nc120wvg.jpg)\n该接口主要是定义了加载资源、解析资源、加载Bean\n\n*AbstractBeanDefinitionReader*\n![AbstractBeanDefinitionReader 源码](http://ww1.sinaimg.cn/large/006TpURwgy1fngfrm27yhj30mq2j5b29.jpg)\n\n该类最重要的方法便是212行的`loadBeanDefinitions(String location, @Nullable Set\u003cResource\u003e actualResources)`方法，我们来具体看看该方法\n首先获取了当前的`ResourceLoader`，接着判断了`resourceLoader`的类型是否是`ResourcePatternResolver`类型，`ResourcePatternResolver`是一个批量加载资源的接口，好了这里不必细究，仅是判断了资源的加载类型，首先假设`if(true)` \n\n```\ntry {\n\t//从指定位置获取资源\n\tResource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);\n\t//通过resources加载bean并获取加载的数量\n\tint loadCount = loadBeanDefinitions(resources);\n\tif (actualResources != null) {\n\t\tfor (Resource resource : resources) {\n\t\t\t//将资源加载至传递进来的actualResources中去\n\t\t\tactualResources.add(resource);\n\t\t}\n\t}\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Loaded \" + loadCount + \" bean definitions from location pattern [\" + location + \"]\");\n\t}\n\t//返回数量\n\treturn loadCount;\n}catch (IOException ex) {\n\tthrow new BeanDefinitionStoreException(\"Could not resolve bean definition resource pattern [\" + location + \"]\", ex);\n}\n```\n\n来看下该类调用的`loadBeanDefinitions(Resource... resources)`方法\n\n```\n@Override\npublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {\n\tAssert.notNull(resources, \"Resource array must not be null\");\n\tint counter = 0;\n\tfor (Resource resource : resources) {\n\t\t//调用了子类的loadBeanDefinitions来加载bean\n\t\tcounter += loadBeanDefinitions(resource);\n\t}\n\treturn counter;\n}\n```\n\n稍等在往下看`loadBeanDefinitions(Resource resource)`方法，先把else的片段看了，因为它也调用了2333333，一次性解决。\n\n```\n//从指定的绝对路径加载一个资源\nResource resource = resourceLoader.getResource(location);\n//调用了子类的loadBeanDefinitions来加载bean\nint loadCount = loadBeanDefinitions(resource);\n\tif (actualResources != null) {\n\t\t//将资源加载至传递进来的actualResources中去\n\t\tactualResources.add(resource);\n\t}\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Loaded \" + loadCount + \" bean definitions from location [\" + location + \"]\");\n\t}\n\t//返回数量\n\treturn loadCount;\n```\n现在我们再回来看子类\n该方法也是`XmlBeanFactory`中`reader`实例所所调用的`loadBeanDefinitions(resource);`\n\n接下来直接涉及到该类是如何实现解析xml中所定义的bean，并且加载进来，内容比较长………所以放在下一篇吧。\n","cover":"","link":"spring_beans_xml_bean_factory.html","preview":"\u003cp\u003e在上一篇说了\u003ccode\u003eDefaultListableBeanFactory\u003c/code\u003e这个类，本篇将会分析它的一个子类\u003ccode\u003eXmlBeanFactory\u003c/code\u003e\u003c/p\u003e\n","title":"Spring源码系列- Spring Beans - Spring Beans-XmlBeanFactory（上）"},{"content":"\n读过上一篇文章的读者应该都能对Spring的体系结构有一个大致的了解，在结尾处，我也说过会从`spring-beans`包开始分析，在重复一下`beans`它主要与配置文件的解析、管理、创建bean及IOC/DI相关。\n\n`beans`和`context`就是Spring实现IOC容器的基础，当然在本章只会提及`beans`不会提及`context`当然在以后的文章会提及到`context`包\n\n在`beans`包中最核心的的一个类之一就是`DefaultListableBeanFactory`，当然这一篇文章会围绕着这个类来进行分解\n首先来了解下`DefaultListBeanFactory`这个类的关系结构\n![DefaultListBeanFactory关系结构](http://ww1.sinaimg.cn/large/006TpURwgy1fn8fhm1z63j31dk0jy77c.jpg)\n该类继承了`AbstractAutowireCapableBeanFactory`并实现了`ConfigurableListableBeanFactory`和`BeanDefinitionRegistry`接口Serializable就不用说了吧？233333\n\n逐一来分析\n\n**AliasRegistry**\n\n该接口主要定义了用于管理别名，提供了别名的注册、删除、获取、以及判断别名的接口。该接口目前定义的接口方法如图\n![AliasRegistry 接口方法](http://ww1.sinaimg.cn/large/006TpURwgy1fn8fj14k7tj30i206egmg.jpg)\n接着是实现了`AliasRegistry`接口的`SimpleAliasRegistry`类\n\n**SimpleAliasRegistry**\n\n该类主要是实现了`AliasRegistry`接口并使用了`Map`对象来存储别名，个人感觉里面没什么好说的，感兴趣的可以自己去看看该类的源码，如有不懂的可以邮件我`yuequan1997@gmail.com`或者加我微信`yuequan1997`都可以。\n接下来左走一步先说`SingletonBeanRegistry`接口，在接着往下说`DefaultSingletonBeanRegistry`\n\n**SingletonBeanRegistry**\n\n该接口主要定义了单例Bean的注册及获取，接口如图，这接口很好理解，笔者感觉不需要解释，如果实在看不懂私聊我吧233333\n![SingletonBeanRegistry 接口方法定义](http://ww1.sinaimg.cn/large/006TpURwgy1fn8fk3caydj30jg08ugmw.jpg)\n接着说`DefaultSingletonBeanRegistry`\n\n**DefaultSingletonBeanRegistry**\n\n该类主要还是实现了`DefaultSingletonBeanRegistry`，笔者认为该实现的和定义几个方法都很好理解，感觉不用太过于去解释，但是该类定义的几个变量还是稍微值得解释下的\n```\n// 缓存所有注册的singleton实例\nprivate final Map\u003cString, Object\u003e singletonObjects = new ConcurrentHashMap\u003c\u003e(256);\n// 缓存singleton 工厂\nprivate final Map\u003cString, ObjectFactory\u003c?\u003e\u003e singletonFactories = new HashMap\u003c\u003e(16);\n// 目前我在该类中看到的作用是用于缓存singleton工厂获取出来的singleton实例\nprivate final Map\u003cString, Object\u003e earlySingletonObjects = new HashMap\u003c\u003e(16);\n// 缓存已注册的singleton实例的beanName\nprivate final Set\u003cString\u003e registeredSingletons = new LinkedHashSet\u003c\u003e(256);\n// 缓存正在创建中的singleton实例\nprivate final Set\u003cString\u003e singletonsCurrentlyInCreation =\n\t\t\tCollections.newSetFromMap(new ConcurrentHashMap\u003c\u003e(16));\n// 缓存不需要获取创建中这种状态的singleton实例\nprivate final Set\u003cString\u003e inCreationCheckExclusions =\n\t\t\tCollections.newSetFromMap(new ConcurrentHashMap\u003c\u003e(16));\n// 缓存发生异常时可以用于抛出异常的类集合\nprivate Set\u003cException\u003e suppressedExceptions;\n// 只需要缓存一次的bean\nprivate final Map\u003cString, Object\u003e disposableBeans = new LinkedHashMap\u003c\u003e();\n// 缓存bean包含的bean names\nprivate final Map\u003cString, Set\u003cString\u003e\u003e containedBeanMap = new ConcurrentHashMap\u003c\u003e(16);\n// 缓存bean依赖的bean names\nprivate final Map\u003cString, Set\u003cString\u003e\u003e dependentBeanMap = new ConcurrentHashMap\u003c\u003e(64);\n// 缓存创建bean时所需要依赖的所有依赖关系\nprivate final Map\u003cString, Set\u003cString\u003e\u003e dependenciesForBeanMap = new ConcurrentHashMap\u003c\u003e(64);\n```\n解决bean的依赖问题的属性主要是\n\n* containedBeanMap\n* dependentBeanMap\n* dependenciesForBeanMap\n\n因为这个类的源码可读性非常的强，想要深入的了解可以自行的去细看该类的源码，这里已经把属性都进行了说明已经更加好阅读实现的逻辑了，笔者也一直希望是授人以鱼不如授人以渔的心态来和大家分享、探讨。\n接下来是`FactoryBeanRegistrySupport`类\n\n**FactoryBeanRegistrySupport**\n\n该类继承了DefaultSingletonBeanRegistry并添加了`factoryBean`的支持\n接下来是`AbstractBeanFactory`?或者`ConfigurableBeanFactory`?，NONONO，我看待事物和分析东西都喜欢从最上面开始当然是`BeanFactory`\n\n**BeanFactory**\n\n该接口主要提供了bean的各种获取方式和bean的各种属性，该篇不会对这一块进行太详细的说明，只需要有个印象即可，以后的章节会分析到这里的。\n\n**HierarchicalBeanFactory**\n\n该接口继承至`BeanFactory`接口在该基础之上新增了获取`parentFactory`和`containsLocalBean`接口方法。\n\n**ConfigurableBeanFactory**\n\n该接口继承至`HierarchicalBeanFactory`和`SingletonBeanFactory`，主要是新增了配置BeanFactory的方法\n接下来是\n\n**AbstractBeanFactory**\n\n该类继承了`FactoryBeanRegistrySupport`并实现了`ConfigurableBeanFactory`接口综合了2者的功能，写着写着发现有好多内容…… 还是以后单独拉一篇写吧，而且目前几篇的重点不在此，先有印象即可。\n接下来是`AbstractAutowireCapableBeanFactory`，嗯，这就太年轻了，我说过，我喜欢从上面开始当然是先说`AutowireCapableBeanFactory`\n\n**AutowireCapableBeanFactory**\n\n该接口继承至`BeanFactory`，该接口主要定义了创建bean、初始化、注入、使用后的`Processors`\n\n**AbstractAutowireCapableBeanFactory**\n\n综合了AbstractBeanFactory的功能并实现了AutowireCapableBeanFactory接口\n\n**ListableBeanFactory**\n\n该接口继承至`BeanFactory`，它主要提供了获取bean的基本信息和bean的配置名和是否包含某一个Bean等接口方法\n\n**ConfigurableListableBeanFactory**\n\n该类继承了\n\n* ListableBeanFactory\n* AutowireCapableBeanFactory\n* ConfigurableBeanFactory\n\n除了拥有父接口的方法外，还提供了获取`BeanDefinition`和预加载以及忽略的类型等接口\n\n**BeanDefinitionRegistry**\n\n该接口继承至`AliasRegistry`接口，还新添加了对`BeanDefinition`的注册、删除还有获取还有是否以及在使用中等接口方法\n\n**DefaultListableBeanFactory**\n\n该类综合了以上所有的功能，它是Spring对注册及加载Bean的默认实现\n\n\u003e 该篇主要是为下几篇做铺垫，不必过于深入，深入的往后会写到，这一篇仅仅是一个过渡的铺垫，剧透时间：接下来会说最经典以前经常用，在3.1后就以及被废弃了的`XmlBeanFactory`，问我为什么要说废弃了的这个类？说了先从bean包开始，推荐的做法跟`context`包息息相关，写到哪里的时候再做详细的赘述，同时去分析`XmlBeanFactory`也是非常有必要的，而且它和现在推荐的做法，在使用还是有点区别的，先不聊了，下篇见。  ","cover":"","link":"spring_beans_core_class_basic_intro.html","preview":"\u003cp\u003e读过上一篇文章的读者应该都能对Spring的体系结构有一个大致的了解，在结尾处，我也说过会从\u003ccode\u003espring-beans\u003c/code\u003e包开始分析，在重复一下\u003ccode\u003ebeans\u003c/code\u003e它主要与配置文件的解析、管理、创建bean及IOC/DI相关。\u003c/p\u003e\n","title":"Spring源码系列- Spring Beans - 核心类的基本介绍"},{"content":"\n# Spring源码系列 - 开篇 - Spring体系结构简介\n\u003e \t此篇有些话说在前头，以免浪费阅读的时间，该篇只需要大致了解并不需要深究，只是为没有认真了解过Spring体系结构的读者为后续章节的阅读做个铺垫，以免对于我分析的那个模块的作用云里雾里，如果说得高大上一点是不是要借用一些惯用的词语：自顶向下？233333开个玩笑。\n\n 我也面临过如何阅读一个框架的源码的问题？该怎么阅读才好？从哪里下手？摸不着头摸不着尾，自己平时也有喜欢做笔记自己跟自己讨论的习惯，感觉还是少了点什么，想把自己理解的拿出来跟大家分享探讨，于是今年自己开始写博客了，也不知道写些什么好，但直接把笔记发出来感觉又有伤大雅，于是我决定开始慢慢的利用博客的博文来梳理自己的知识体系，近期的博客可能都会围绕着Spring的源码分析、多线程相关的知识。\n\nSpring这个框架我就不多介绍，玩Java的应该都知道这个大名鼎鼎的框架，当然个人感觉Spring已经不能用这个框架这种词语来形容了，它已经是一个很庞大的生态了(PS: 感谢这些贡献者)，先简单介绍一下Spring的体系结构，哦对了我写这个系列博文使用的Spring版本是5.0.2\n![该图来自于Spring官方](https://ws1.sinaimg.cn/large/7fd2951agy1fn2oaj5fcuj20k00f00ti.jpg)\n**Core Container模块**\n\n根据上图可以看到该模块主要包含了beans、core、context、SpEL几个内容，`core`和`beans`这2个模块提供了整个框架的基础，它提供了IOC和注入反转的功能，其中最主要的是BeanFactory看名字就知道它是使用工厂模式进行的实现，它能弱化你程序化单例模式的需要(如果理解不了的就简单的理解为它不需要你去显式的编写一些对象的单例其实不止单纯的单例这么简单，慢慢来吧233333)，可以将配置和特定的依赖关系进行解耦。\n\ncore(spring-core):\n    该模块主要包含了Spring框架的核心工具类，基本上所有的Spring组件都会使用到该模块中的类，它可以说的上是整个框架的核心了\n\nbeans(spring-beans):\n    该模块基本所有应用都会应用到，它提供了配置文件的解析、创建、管理bean以及进行IOC/DI等操作相关的类\n\ncontext(spring-context):\n    该模块是建立在`core`和`beans`模块的基础之上，它提供了一种类似于JNDI注册器的对象访问方法，同时`context`模块继承了`beans`模块的一些特性，提供了大量的扩展并且添加了对国际化、事件传播、资源加载和创建Context的支持，同时`context`模块也支持J2EE的一些特性，比如EJB、JMX和基础的远程处理，其中的ApplicationContext接口是该模块的关键核心，后续会分析到该接口，现在就不做太详细的描述了\n\nSpEL(spring-expression):\n    该模块提供了强大的b表达式语言用于在运行时操作对象，它是JSP2.1规范所指定的统一表达式语言的扩展，该语言支持设置和获取属性的值、属性的分配、方法的调用、数组内容的存储、容器和索引、逻辑和算术运算符、命名变量以及从Spring的 IoC容器中根据名称检索对象。当然常见的集合操作也是支持的\n\t\n**AOP / Instrumentation 模块**\n\nAOP模块提供了符合AOP联盟的面向切面编程的实现，同时它也允许你自定义例如：方法拦截器和切入点，将逻辑代码和方法拦截器的代码彻底分开，降低他们之间耦合性，利用 source-level 的元数据功能，还可以将各种行为信息合并到你的代码中，这有点像.Net技术中的attribute概念\n单独的spring-aspects模块提供了AspectJ的集成和使用。\n`instrument`模块提供了`class instrumentation`的支持以及在某些应用程序服务器使用类加载器实现。\n\n**Messaging 模块**\n\n该模块是Spring4以后引入的，是从Spring集成项目中抽象出来的，例如Message、MessageChannel、MessageHandler以及其他用来提供基于消息的基础服务，该模块还包括了能将消息映射到方法的注解，类似于基于编程模型的Spring MVC注解。\n\n**Data Access/Integration 模块**\n\n该模块由由JDBC、ORM、OXM、JMS和事务模块组成\njdbc(spring-jdbc): 玩Java的应该都知道JDBC没有经过封装时写起来的时候有多么的冗长吧..，该模块主要对JDBC进行了封装\ntrasaction(spring-tx): 该模块提供了可编程和声明式事务管理，这些类都必须实现特定的接口，并且对所有POJO都适用。\n\norm(spring-orm): 该模块提供了流行的对象关系映射(ORM)API提供了一个交互层，例如JPA、JDO、Hibernate、MyBatis等，利用该模块的封装可以在Spring提供的特性上使用所有的O/R映射框架与Spring提供的其它功能进行结合使用，说白了就是对这些ORM框架进行集成，如果这样好理解就这样理解吧,233333\n\noxm(spring-oxm):该模块提供了一个对Object / XML映射实现的抽象层，Object/XML映射实现包括JAXB、Castor、XMLBeans、JiBX和XStream，如果理解不了的话,可以简单的理解为就是xml转换成对象，233333。\n\njms:该模块用于生产和消费消息的功能，从Spring4.1开始提供集成`messaging`模块\n\n**Web模块**\n\n该模块由web、webmvc、websocket、portlet模块构成\n\nweb(spring-web):该模块提供了基本的面向Web开发的集成功能，例如文件上传、使用Servlet listeners和Web开发应用程序上下文初始化IOC容器,也包含HTTP客户端以及Spring有关Web部分的远程访问支持\n\nwebmvc(spring-webmvc): 该模块也被称为Web-Servlet模块，包含Spring的model-view-controller(MVC)的实现和REST Web Services的实现, Spring的MVC框架使得模型范围内的代码和web forms之间能够清楚地分离开来，并与Spring框架的其他特性集成在一起\n\nportlet(spring-webmvc-portlet)：该模块也被称为Web-Portlet模块，提供了MVC模式的实现，使用Portlet环境和webmvc模块功能的镜像，其实这块已经在Spring 5中已经被废弃被webflux模块取代23333\n\n**Test模块**\n\nspring-test模块支持通过集成JUnit或TestNG来进行单元测试和集成测试，它提供了持续加载ApplicationContext并且会缓存这些上下文，而且它还提供了Mock对象可以用来隔离测试代码~~~\n\n大致就了解到这里了，剧透一波我会从beans模块的源码开始写博客~~~~ 2333 ，祝大家新年快乐！。\n","cover":"","link":"spring_start_struct_intro.html","preview":"\u003cp\u003e新年好，此章对Spring的体系结构进行的一些简明的说明。\u003c/p\u003e\n","title":"Spring源码系列 - 开篇 - Spring体系结构简介"},{"content":"\n# 博客开通了\n大家新年好，我决定从今年开始写博客啦！","cover":"","link":"blog_start.html","preview":"\u003cp\u003e大家新年好呀！\u003c/p\u003e\n","title":"博客开通了"}]